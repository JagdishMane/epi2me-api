/**
 * Copyright Metrichor Ltd. (An Oxford Nanopore Technologies Company) 2020
 */

"use strict";function e(e){return e&&"object"===typeof e&&"default"in e?e.default:e}var t=e(require("aws-sdk")),s=e(require("fs-extra")),i=require("lodash"),o=require("os"),r=e(o),n=e(require("path")),a=e(require("sqlite")),l=e(require("axios")),c=e(require("crypto")),h=require("tunnel"),u=require("rxjs"),d=e(require("graphql-tag")),p=require("@apollo/client/core"),f=require("@lifeomic/axios-fetch"),g=e(require("socket.io-client")),w=require("zlib"),m=e(w),y=e(require("fdir")),v=e(require("proxy-agent")),b=e(require("readline")),k=require("util"),S="undefined"!==typeof globalThis?globalThis:"undefined"!==typeof window?window:"undefined"!==typeof global?global:"undefined"!==typeof self?self:{};function _(e,t,s){return e(s={path:t,exports:{},require:function(e,t){return function(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}((void 0===t||null===t)&&s.path)}},s.exports),s.exports}var E=_((function(e,t){!function(s){var i=t&&!t.nodeType&&t,o=e&&!e.nodeType&&e,r="object"==typeof S&&S;r.global!==r&&r.window!==r&&r.self!==r||(s=r);var n,a,l=2147483647,c=/^xn--/,h=/[^\x20-\x7E]/,u=/[\x2E\u3002\uFF0E\uFF61]/g,d={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},p=Math.floor,f=String.fromCharCode;function g(e){throw RangeError(d[e])}function w(e,t){for(var s=e.length,i=[];s--;)i[s]=t(e[s]);return i}function m(e,t){var s=e.split("@"),i="";return s.length>1&&(i=s[0]+"@",e=s[1]),i+w((e=e.replace(u,".")).split("."),t).join(".")}function y(e){for(var t,s,i=[],o=0,r=e.length;o<r;)(t=e.charCodeAt(o++))>=55296&&t<=56319&&o<r?56320==(64512&(s=e.charCodeAt(o++)))?i.push(((1023&t)<<10)+(1023&s)+65536):(i.push(t),o--):i.push(t);return i}function v(e){return w(e,(function(e){var t="";return e>65535&&(t+=f((e-=65536)>>>10&1023|55296),e=56320|1023&e),t+=f(e)})).join("")}function b(e,t){return e+22+75*(e<26)-((0!=t)<<5)}function k(e,t,s){var i=0;for(e=s?p(e/700):e>>1,e+=p(e/t);e>455;i+=36)e=p(e/35);return p(i+36*e/(e+38))}function _(e){var t,s,i,o,r,n,a,c,h,u,d,f=[],w=e.length,m=0,y=128,b=72;for((s=e.lastIndexOf("-"))<0&&(s=0),i=0;i<s;++i)e.charCodeAt(i)>=128&&g("not-basic"),f.push(e.charCodeAt(i));for(o=s>0?s+1:0;o<w;){for(r=m,n=1,a=36;o>=w&&g("invalid-input"),((c=(d=e.charCodeAt(o++))-48<10?d-22:d-65<26?d-65:d-97<26?d-97:36)>=36||c>p((l-m)/n))&&g("overflow"),m+=c*n,!(c<(h=a<=b?1:a>=b+26?26:a-b));a+=36)n>p(l/(u=36-h))&&g("overflow"),n*=u;b=k(m-r,t=f.length+1,0==r),p(m/t)>l-y&&g("overflow"),y+=p(m/t),m%=t,f.splice(m++,0,y)}return v(f)}function E(e){var t,s,i,o,r,n,a,c,h,u,d,w,m,v,S,_=[];for(w=(e=y(e)).length,t=128,s=0,r=72,n=0;n<w;++n)(d=e[n])<128&&_.push(f(d));for(i=o=_.length,o&&_.push("-");i<w;){for(a=l,n=0;n<w;++n)(d=e[n])>=t&&d<a&&(a=d);for(a-t>p((l-s)/(m=i+1))&&g("overflow"),s+=(a-t)*m,t=a,n=0;n<w;++n)if((d=e[n])<t&&++s>l&&g("overflow"),d==t){for(c=s,h=36;!(c<(u=h<=r?1:h>=r+26?26:h-r));h+=36)S=c-u,v=36-u,_.push(f(b(u+S%v,0))),c=p(S/v);_.push(f(b(c,0))),r=k(s,m,i==o),s=0,++i}++s,++t}return _.join("")}if(n={version:"1.3.2",ucs2:{decode:y,encode:v},decode:_,encode:E,toASCII:function(e){return m(e,(function(e){return h.test(e)?"xn--"+E(e):e}))},toUnicode:function(e){return m(e,(function(e){return c.test(e)?_(e.slice(4).toLowerCase()):e}))}},i&&o)if(e.exports==i)o.exports=n;else for(a in n)n.hasOwnProperty(a)&&(i[a]=n[a]);else s.punycode=n}(S)}));function I(e,t){return Object.prototype.hasOwnProperty.call(e,t)}var $=function(e,t,s,i){t=t||"&",s=s||"=";var o={};if("string"!==typeof e||0===e.length)return o;var r=/\+/g;e=e.split(t);var n=1e3;i&&"number"===typeof i.maxKeys&&(n=i.maxKeys);var a=e.length;n>0&&a>n&&(a=n);for(var l=0;l<a;++l){var c,h,u,d,p=e[l].replace(r,"%20"),f=p.indexOf(s);f>=0?(c=p.substr(0,f),h=p.substr(f+1)):(c=p,h=""),u=decodeURIComponent(c),d=decodeURIComponent(h),I(o,u)?Array.isArray(o[u])?o[u].push(d):o[u]=[o[u],d]:o[u]=d}return o},T=function(e){switch(typeof e){case"string":return e;case"boolean":return e?"true":"false";case"number":return isFinite(e)?e:"";default:return""}},O=function(e,t,s,i){return t=t||"&",s=s||"=",null===e&&(e=void 0),"object"===typeof e?Object.keys(e).map((function(i){var o=encodeURIComponent(T(i))+s;return Array.isArray(e[i])?e[i].map((function(e){return o+encodeURIComponent(T(e))})).join(t):o+encodeURIComponent(T(e[i]))})).join(t):i?encodeURIComponent(T(i))+s+encodeURIComponent(T(e)):""},x=_((function(e,t){t.decode=t.parse=$,t.encode=t.stringify=O})),j=function(e,t){return L(e,!1,!0).resolve(t)};function P(){this.protocol=null,this.slashes=null,this.auth=null,this.host=null,this.port=null,this.hostname=null,this.hash=null,this.search=null,this.query=null,this.pathname=null,this.path=null,this.href=null}var R=/^([a-z0-9.+-]+:)/i,A=/:[0-9]*$/,C=["{","}","|","\\","^","`"].concat(["<",">",'"',"`"," ","\r","\n","\t"]),N=["'"].concat(C),q=["%","/","?",";","#"].concat(N),F=["/","?","#"],M=/^[a-z0-9A-Z_-]{0,63}$/,W=/^([a-z0-9A-Z_-]{0,63})(.*)$/,D={javascript:!0,"javascript:":!0},z={javascript:!0,"javascript:":!0},U={http:!0,https:!0,ftp:!0,gopher:!0,file:!0,"http:":!0,"https:":!0,"ftp:":!0,"gopher:":!0,"file:":!0};function L(e,t,s){if(e&&H(e)&&e instanceof P)return e;var i=new P;return i.parse(e,t,s),i}function Q(e){return"string"===typeof e}function H(e){return"object"===typeof e&&null!==e}function J(e){return null===e}P.prototype.parse=function(e,t,s){if(!Q(e))throw new TypeError("Parameter 'url' must be a string, not "+typeof e);var i=e;i=i.trim();var o=R.exec(i);if(o){var r=(o=o[0]).toLowerCase();this.protocol=r,i=i.substr(o.length)}if(s||o||i.match(/^\/\/[^@\/]+@[^@\/]+/)){var n="//"===i.substr(0,2);!n||o&&z[o]||(i=i.substr(2),this.slashes=!0)}if(!z[o]&&(n||o&&!U[o])){for(var a,l,c=-1,h=0;h<F.length;h++){-1!==(u=i.indexOf(F[h]))&&(-1===c||u<c)&&(c=u)}-1!==(l=-1===c?i.lastIndexOf("@"):i.lastIndexOf("@",c))&&(a=i.slice(0,l),i=i.slice(l+1),this.auth=decodeURIComponent(a)),c=-1;for(h=0;h<q.length;h++){var u;-1!==(u=i.indexOf(q[h]))&&(-1===c||u<c)&&(c=u)}-1===c&&(c=i.length),this.host=i.slice(0,c),i=i.slice(c),this.parseHost(),this.hostname=this.hostname||"";var d="["===this.hostname[0]&&"]"===this.hostname[this.hostname.length-1];if(!d)for(var p=this.hostname.split(/\./),f=(h=0,p.length);h<f;h++){var g=p[h];if(g&&!g.match(M)){for(var w="",m=0,y=g.length;m<y;m++)g.charCodeAt(m)>127?w+="x":w+=g[m];if(!w.match(M)){var v=p.slice(0,h),b=p.slice(h+1),k=g.match(W);k&&(v.push(k[1]),b.unshift(k[2])),b.length&&(i="/"+b.join(".")+i),this.hostname=v.join(".");break}}}if(this.hostname.length>255?this.hostname="":this.hostname=this.hostname.toLowerCase(),!d){var S=this.hostname.split("."),_=[];for(h=0;h<S.length;++h){var I=S[h];_.push(I.match(/[^A-Za-z0-9_-]/)?"xn--"+E.encode(I):I)}this.hostname=_.join(".")}var $=this.port?":"+this.port:"",T=this.hostname||"";this.host=T+$,this.href+=this.host,d&&(this.hostname=this.hostname.substr(1,this.hostname.length-2),"/"!==i[0]&&(i="/"+i))}if(!D[r])for(h=0,f=N.length;h<f;h++){var O=N[h],j=encodeURIComponent(O);j===O&&(j=escape(O)),i=i.split(O).join(j)}var P=i.indexOf("#");-1!==P&&(this.hash=i.substr(P),i=i.slice(0,P));var A=i.indexOf("?");if(-1!==A?(this.search=i.substr(A),this.query=i.substr(A+1),t&&(this.query=x.parse(this.query)),i=i.slice(0,A)):t&&(this.search="",this.query={}),i&&(this.pathname=i),U[r]&&this.hostname&&!this.pathname&&(this.pathname="/"),this.pathname||this.search){$=this.pathname||"",I=this.search||"";this.path=$+I}return this.href=this.format(),this},P.prototype.format=function(){var e=this.auth||"";e&&(e=(e=encodeURIComponent(e)).replace(/%3A/i,":"),e+="@");var t=this.protocol||"",s=this.pathname||"",i=this.hash||"",o=!1,r="";this.host?o=e+this.host:this.hostname&&(o=e+(-1===this.hostname.indexOf(":")?this.hostname:"["+this.hostname+"]"),this.port&&(o+=":"+this.port)),this.query&&H(this.query)&&Object.keys(this.query).length&&(r=x.stringify(this.query));var n=this.search||r&&"?"+r||"";return t&&":"!==t.substr(-1)&&(t+=":"),this.slashes||(!t||U[t])&&!1!==o?(o="//"+(o||""),s&&"/"!==s.charAt(0)&&(s="/"+s)):o||(o=""),i&&"#"!==i.charAt(0)&&(i="#"+i),n&&"?"!==n.charAt(0)&&(n="?"+n),t+o+(s=s.replace(/[?#]/g,(function(e){return encodeURIComponent(e)})))+(n=n.replace("#","%23"))+i},P.prototype.resolve=function(e){return this.resolveObject(L(e,!1,!0)).format()},P.prototype.resolveObject=function(e){if(Q(e)){var t=new P;t.parse(e,!1,!0),e=t}var s=new P;if(Object.keys(this).forEach((function(e){s[e]=this[e]}),this),s.hash=e.hash,""===e.href)return s.href=s.format(),s;if(e.slashes&&!e.protocol)return Object.keys(e).forEach((function(t){"protocol"!==t&&(s[t]=e[t])})),U[s.protocol]&&s.hostname&&!s.pathname&&(s.path=s.pathname="/"),s.href=s.format(),s;if(e.protocol&&e.protocol!==s.protocol){if(!U[e.protocol])return Object.keys(e).forEach((function(t){s[t]=e[t]})),s.href=s.format(),s;if(s.protocol=e.protocol,e.host||z[e.protocol])s.pathname=e.pathname;else{for(var i=(e.pathname||"").split("/");i.length&&!(e.host=i.shift()););e.host||(e.host=""),e.hostname||(e.hostname=""),""!==i[0]&&i.unshift(""),i.length<2&&i.unshift(""),s.pathname=i.join("/")}if(s.search=e.search,s.query=e.query,s.host=e.host||"",s.auth=e.auth,s.hostname=e.hostname||e.host,s.port=e.port,s.pathname||s.search){var o=s.pathname||"",r=s.search||"";s.path=o+r}return s.slashes=s.slashes||e.slashes,s.href=s.format(),s}var n=s.pathname&&"/"===s.pathname.charAt(0),a=e.host||e.pathname&&"/"===e.pathname.charAt(0),l=a||n||s.host&&e.pathname,c=l,h=s.pathname&&s.pathname.split("/")||[],u=(i=e.pathname&&e.pathname.split("/")||[],s.protocol&&!U[s.protocol]);if(u&&(s.hostname="",s.port=null,s.host&&(""===h[0]?h[0]=s.host:h.unshift(s.host)),s.host="",e.protocol&&(e.hostname=null,e.port=null,e.host&&(""===i[0]?i[0]=e.host:i.unshift(e.host)),e.host=null),l=l&&(""===i[0]||""===h[0])),a)s.host=e.host||""===e.host?e.host:s.host,s.hostname=e.hostname||""===e.hostname?e.hostname:s.hostname,s.search=e.search,s.query=e.query,h=i;else if(i.length)h||(h=[]),h.pop(),h=h.concat(i),s.search=e.search,s.query=e.query;else if(null!=e.search){if(u)s.hostname=s.host=h.shift(),(w=!!(s.host&&s.host.indexOf("@")>0)&&s.host.split("@"))&&(s.auth=w.shift(),s.host=s.hostname=w.shift());return s.search=e.search,s.query=e.query,J(s.pathname)&&J(s.search)||(s.path=(s.pathname?s.pathname:"")+(s.search?s.search:"")),s.href=s.format(),s}if(!h.length)return s.pathname=null,s.search?s.path="/"+s.search:s.path=null,s.href=s.format(),s;for(var d=h.slice(-1)[0],p=(s.host||e.host)&&("."===d||".."===d)||""===d,f=0,g=h.length;g>=0;g--)"."==(d=h[g])?h.splice(g,1):".."===d?(h.splice(g,1),f++):f&&(h.splice(g,1),f--);if(!l&&!c)for(;f--;f)h.unshift("..");!l||""===h[0]||h[0]&&"/"===h[0].charAt(0)||h.unshift(""),p&&"/"!==h.join("/").substr(-1)&&h.push("");var w,m=""===h[0]||h[0]&&"/"===h[0].charAt(0);u&&(s.hostname=s.host=m?"":h.length?h.shift():"",(w=!!(s.host&&s.host.indexOf("@")>0)&&s.host.split("@"))&&(s.auth=w.shift(),s.host=s.hostname=w.shift()));return(l=l||s.host&&h.length)&&!m&&h.unshift(""),h.length?s.pathname=h.join("/"):(s.pathname=null,s.path=null),J(s.pathname)&&J(s.search)||(s.path=(s.pathname?s.pathname:"")+(s.search?s.search:"")),s.auth=e.auth||s.auth,s.slashes=s.slashes||e.slashes,s.href=s.format(),s},P.prototype.parseHost=function(){var e=this.host,t=A.exec(e);t&&(":"!==(t=t[0])&&(this.port=t.substr(1)),e=e.substr(0,e.length-t.length)),e&&(this.hostname=e)};var G="3.0.1839";const B=(...e)=>{},K={debug:B,error:B,info:B,warn:B},V={info(...e){console.info(`[${(new Date).toISOString()}] INFO:`,...e)},debug(...e){console.debug(`[${(new Date).toISOString()}] DEBUG:`,...e)},warn(...e){console.warn(`[${(new Date).toISOString()}] WARN:`,...e)},error(...e){console.error(`[${(new Date).toISOString()}] ERROR:`,...e)}};function X(e){return"object"===typeof e&&!1===Array.isArray(e)}function Y(e){return"function"===typeof e}function Z(e){return"boolean"===typeof e}function ee(e){return"string"===typeof e}function te(e){return"number"===typeof e}function se(e){return"number"===typeof e||"string"===typeof e}function ie(e){return Array.isArray(e)}function oe(e){return"undefined"===typeof e}function re(e){return null===e||"undefined"===typeof e}function ne(e,t){if(ee(e))return e;if(re(e)&&"undefined"!==typeof t)return t;throw new Error(`Unable to cast ${typeof e} to String`)}function ae(e,t){if(te(e))return e;if(re(e)&&"undefined"!==typeof t)return t;throw new Error(`Unable to cast ${typeof e} to Number`)}function le(e){if(ee(e))return e;if(te(e)||Z(e))return e.toString();throw new Error(`Unable to cast ${typeof e} to String`)}function ce(e){if(te(e))return e;if(ee(e)){const t=parseFloat(e);if(!isNaN(t))return t}if(Z(e))return+e;throw new Error(`Unable to cast ${typeof e} to Number`)}function he(e,t){if(se(e))return e;if(re(e)&&"undefined"!==typeof t)return t;throw new Error(`Unable to cast ${typeof e} to Index`)}function ue(e,t){if(X(e))return e;if(re(e)&&"undefined"!==typeof t)return t;throw new Error(`Unable to cast ${typeof e} to Indexable`)}function de(e,t){if(Z(e))return e;if(re(e)&&"undefined"!==typeof t)return t;throw new Error(`Unable to cast ${typeof e} to Boolean`)}function pe(e,t){if(ie(e))return e;if(re(e)&&"undefined"!==typeof t)return t;throw new Error(`Unable to cast ${typeof e} to Array`)}function fe(e,t){if(X(e))return e;if(re(e)&&"undefined"!==typeof t)return t;throw new Error(`Unable to cast ${typeof e} to Record`)}function ge(e,t){if(Y(e))return e;if(re(e)&&"undefined"!==typeof t)return t;throw new Error(`Unable to cast ${typeof e} to Function`)}function we(e,t,s){if(re(e)&&"undefined"!==typeof s)return s;if(ie(e))return e.map(t);throw new Error(`Unable to cast ${typeof e} to Array`)}function me(e){if(!re(e))return ne(e)}function ye(e){if(!re(e))return ae(e)}function ve(e){if(!re(e))return he(e)}function be(e){if(!re(e))return de(e)}function ke(e){if(!re(e))return fe(e)}function Se(e){if(!re(e))return ge(e)}l.defaults.validateStatus=e=>e<=504;const _e=function(){const e={sign:(e,t)=>{var s,i;if(!t)return;if(e.headers||(e.headers={}),!t.apikey)return;if(e.headers["X-EPI2ME-ApiKey"]=t.apikey,!t.apisecret)return;e.headers["X-EPI2ME-SignatureDate"]=(new Date).toISOString(),(null===(s=e.url)||void 0===s?void 0:s.match(/^https:/))&&(e.url=e.url.replace(/:443/,"")),(null===(i=e.url)||void 0===i?void 0:i.match(/^http:/))&&(e.url=e.url.replace(/:80/,""));const o=[e.url,Object.keys(e.headers).sort().filter(e=>e.match(/^x-epi2me/i)).map(t=>`${t}:${e.headers[t]}`).join("\n")].join("\n"),r=c.createHmac("sha1",t.apisecret).update(o).digest("hex");e.headers["X-EPI2ME-SignatureV0"]=r},responseHandler(e){const t=e&&X(e.data)?e.data:null;if(e&&e.status>=400){let s="Network error "+e.status;throw(null===t||void 0===t?void 0:t.error)&&(s=t.error+""),504===e.status&&(s="Please check your network connection and try again."),new Error(s)}if(!t)throw new Error("unexpected non-json response");if(t.error)throw new Error(t.error+"");return t}};return{version:"3.0.1839",headers(t,s){var i,o;if(t.headers=Object.assign(Object.assign({Accept:"application/json","Content-Type":"application/json","X-EPI2ME-Client":s.user_agent||"api","X-EPI2ME-Version":s.agent_version||_e.version},t.headers),s.headers),(null===(i=s.signing)||void 0===i||i)&&e.sign(t,s),s.proxy){const e=s.proxy.match(/https?:\/\/((\S+):(\S+)@)?(\S+):(\d+)/);if(!e)throw new Error("Failed to parse Proxy URL");const i=e[2],r=e[3],n={host:e[4],port:parseInt(e[5],10)};i&&r&&(n.proxyAuth=`${i}:${r}`);const a=null!==(o=s.log)&&void 0!==o?o:K;s.proxy.match(/^https/)?(a.debug("using HTTPS over HTTPS proxy",JSON.stringify(n)),t.httpsAgent=h.httpsOverHttps({proxy:n})):(a.debug("using HTTPS over HTTP proxy",JSON.stringify(n)),t.httpsAgent=h.httpsOverHttp({proxy:n})),t.proxy=!1}},async head(e,t){var s;const i={url:this.mangleURL(e,t)};if(this.headers(i,t),!i.url)throw new Error("unreachable: url argument in HEAD was deleted");(null!==(s=t.log)&&void 0!==s?s:K).debug("HEAD",i.url);const o=await l.head(i.url,i);if(o&&o.status>=400){if(504===o.status)throw new Error("Please check your network connection and try again.");throw new Error("Network error "+o.status)}return o},async get(t,s){var i;const o={url:this.mangleURL(t,s)};if(this.headers(o,s),!o.url)throw new Error("unreachable: url argument in GET was deleted");(null!==(i=s.log)&&void 0!==i?i:K).debug("GET",o.url);const r=await l.get(o.url,o);return e.responseHandler(r)},async post(t,s,i){var o;let r=i.url;r=r.replace(/\/+$/,"");const n={url:`${r}/${t.replace(/\/+/g,"/")}`,data:s,headers:{}};i.legacy_form&&this.processLegacyForm(n,s),this.headers(n,i);const{data:a}=n;delete n.data;const c=null!==(o=i.log)&&void 0!==o?o:K;if(!n.url)throw new Error("unreachable: url argument in POST was deleted");c.debug("POST",n.url);const h=await l.post(n.url,a,n);return i.handler?i.handler(h):e.responseHandler(h)},async put(t,s,i,o){var r;let n=o.url;n=n.replace(/\/+$/,"");const a={url:`${n}/${t.replace(/\/+/g,"/")}/${s}`,data:i,headers:{}};o.legacy_form&&this.processLegacyForm(a,i),this.headers(a,o);const{data:c}=a;delete a.data;const h=null!==(r=o.log)&&void 0!==r?r:K;if(!a.url)throw new Error("unreachable: url argument in PUT was deleted");h.debug("PUT",a.url);const u=await l.put(a.url,c,a);return e.responseHandler(u)},mangleURL(e,t){let s=t.url;return t.skip_url_mangle?e:(e="/"+e,s=s.replace(/\/+$/,""),s+(e=e.replace(/\/+/g,"/")))},processLegacyForm(e,t){const s=[],i=Object.assign({json:JSON.stringify(t)},t);Object.keys(i).sort().forEach(e=>{s.push(`${e}=${escape(i[e]+"")}`)}),e.data=s.join("&"),e.headers["Content-Type"]="application/x-www-form-urlencoded"},convertResponseToObject(e){if("object"===typeof e)return e;try{return JSON.parse(e)}catch(t){throw new Error("exception parsing chain JSON "+String(t))}}}}();let Ee=0;const Ie=Object.assign(Object.assign({},_e),{async pipe(e,t,i,o){var r;let n=i.url,a="/"+e;n=n.replace(/\/+$/,""),a=a.replace(/\/+/g,"/");const c={url:n+a,headers:{"Accept-Encoding":"gzip",Accept:"application/gzip"}};if(this.headers(c,i),i.proxy){const e=i.proxy.match(/https?:\/\/((\S+):(\S+)@)?(\S+):(\d+)/);if(!e)throw new Error("Failed to parse Proxy URL");const t=e[2],s=e[3],o={host:e[4],port:parseInt(e[5],10)};t&&s&&(o.proxyAuth=`${t}:${s}`);const n=null!==(r=i.log)&&void 0!==r?r:K;i.proxy.match(/^https/)?(n.debug("using HTTPS over HTTPS proxy",JSON.stringify(o)),c.httpsAgent=h.httpsOverHttps({proxy:o})):(n.debug("using HTTPS over HTTP proxy",JSON.stringify(o)),c.httpsAgent=h.httpsOverHttp({proxy:o})),c.proxy=!1}if(o&&(c.onUploadProgress=o),c.responseType="stream",!c.url)throw new Error("unreachable: url argument in PIPE was deleted");const u=await l.get(c.url,c);return new Promise((e,i)=>{const o=s.createWriteStream(t);u.data.pipe(o),o.on("finish",()=>{e(t)}),o.on("error",e=>{i(new Error("writer failed "+String(e)))})})},getFileID:()=>(Ee+=1,"FILE_"+Ee),async lsRecursive(e,t,i){let o=e;const r=s.statSync(t);if(i){if(await i(t,r))return[]}if(r.isDirectory()){const e=await s.readdir(t),r=[];for(const s of e){const e=n.join(t,s);for(const t of await this.lsRecursive(o,e,i))r.push(t)}return r}return r.isFile()&&o===t&&(o=n.dirname(t)),[{name:n.parse(t).base,path:t,relative:t.replace(o,""),size:r.size,id:this.getFileID()}]},async loadInputFiles({inputFolders:e,outputFolder:t,filetype:s},i,o){let r;r=Array.isArray(s)?s:[s],r=r.map(e=>e&&0!==e.indexOf(".")?"."+e:e);const a=async(e,s)=>{const i=n.basename(e),a=[new Promise((t,s)=>"downloads"===i||"skip"===i||"fail"===i||"fastq_fail"===i||"tmp"===i?s(new Error(e+" failed basic filename")):t("basic ok")),new Promise((o,a)=>{const l=r.length?new RegExp(`(?:${r.join("|")})$`):null;return e.split(n.sep).filter(e=>e.match(/^[.]/)).length||t&&i===n.basename(t)||l&&!e.match(l)&&s.isFile()?a(new Error(e+" failed extended filename")):o("extended ok")}),o?new Promise((t,s)=>{o(e).then(i=>i?s(new Error(e+" failed extraFilter")):t("extra ok"))}):Promise.resolve("extra skip")];try{return await Promise.all(a),!1}catch(l){return!0}},l=[];for(const n of e){const e=await this.lsRecursive(n,n,a);l.push(...e.filter(e=>!!e))}return l},stripFile:e=>[n.dirname(e),n.basename(e)]});class $e{constructor(e,t,o){const r=i.merge({},t);this.options=r,this.log=o;const{idWorkflowInstance:l,inputFolders:c}=r;o.debug(`setting up ${e}/db.sqlite for ${l}`),this.db=s.mkdirp(e).then(()=>(this.log.debug(`opening ${e}/db.sqlite`),a.open(n.join(e,"db.sqlite")).then(async t=>{this.log.debug(`opened ${e}/db.sqlite`),await t.migrate({migrationsPath:n.join(__dirname,"migrations")});const s=c.map(()=>"(?)").join(",");try{return await Promise.all([t.run("INSERT INTO meta (version, idWorkflowInstance) VALUES(?, ?)",G,l),t.run("INSERT INTO folders (folder_path) VALUES "+s,c)]),t}catch(i){return this.log.error(i),Promise.reject(i)}}))).catch(e=>{throw this.log.error(e),e})}async uploadFile(e){const t=await this.db,[s,i]=Ie.stripFile(e);return await t.run("INSERT OR IGNORE INTO folders (folder_path) VALUES (?)",s),t.run("INSERT INTO uploads(filename, path_id) VALUES(?, (SELECT folder_id FROM folders WHERE folder_path = ?))",i,s)}async skipFile(e){const t=await this.db,[s,i]=Ie.stripFile(e);return await t.run("INSERT OR IGNORE INTO folders (folder_path) VALUES (?)",s),t.run("INSERT INTO skips(filename, path_id) VALUES(?, (SELECT folder_id FROM folders WHERE folder_path = ?))",i,s)}async splitFile(e,t){const s=await this.db,[i,o]=Ie.stripFile(e),r=Ie.stripFile(t)[1];return await s.run("INSERT OR IGNORE INTO folders (folder_path) VALUES (?)",i),s.run("INSERT INTO splits(filename, parent, child_path_id, start, end) VALUES(?, ?, (SELECT folder_id FROM folders WHERE folder_path = ?), CURRENT_TIMESTAMP, NULL)",o,r,i)}async splitDone(e){const t=await this.db,[s,i]=Ie.stripFile(e);return t.run("UPDATE splits SET end=CURRENT_TIMESTAMP WHERE filename=? AND child_path_id=(SELECT folder_id FROM folders WHERE folder_path=?)",i,s)}async splitClean(){const e=await this.db,t=await e.all("SELECT splits.filename, folders.folder_path FROM splits INNER JOIN folders ON folders.folder_id = splits.child_path_id WHERE end IS NULL");if(!t)return void this.log.info("no split files to clean");this.log.info(`cleaning ${t.length} split files`),this.log.debug("going to clean: "+t.map(e=>e.filename).join(" "));const i=t.map(e=>s.unlink(n.join(e.folder_path,e.filename)).catch(()=>{console.warn("Failed to cleanup "+n.join(e.folder_path,e.filename))}));await Promise.all(i)}async seenUpload(e){const t=await this.db,[s,o]=Ie.stripFile(e);return Promise.all([t.get("SELECT * FROM uploads u INNER JOIN folders ON folders.folder_id = u.path_id WHERE u.filename=? AND folders.folder_path=? LIMIT 1",[o,s]),t.get("SELECT * FROM skips s INNER JOIN folders ON folders.folder_id = s.path_id WHERE s.filename=? AND folders.folder_path=? LIMIT 1",o,s)]).then(e=>i.remove(e,void 0).length)}}var Te=!1,Oe="https://epi2me.nanoporetech.com",xe="EPI2ME API",je="eu-west-1",Pe=5,Re=1200,Ae=1200,Ce=5,Ne=3,qe=60,Fe=600,Me=20,We=30,De=3,ze="data+telemetry",Ue=[".fastq",".fq",".fastq.gz",".fq.gz"],Le=!0,Qe="/data";const He="\npage\npages\nhasNext\nhasPrevious\ntotalCount\n",Je="\nidWorkflowInstance\nstartDate\nworkflowImage{\n  workflow\n  {\n    rev\n    name\n  }\n}\n",Ge=(()=>{const e=(e,t={})=>{if(e.headers||(e.headers={}),!t.apikey||!t.apisecret)return;e.headers["X-EPI2ME-APIKEY"]=t.apikey,e.headers["X-EPI2ME-SIGNATUREDATE"]=(new Date).toISOString();const s=[Object.keys(e.headers).sort().filter(e=>e.match(/^x-epi2me/i)).map(t=>`${t}:${e.headers[t]}`).join("\n"),e.body].join("\n"),i=c.createHmac("sha1",t.apisecret).update(s).digest("hex");e.headers["X-EPI2ME-SIGNATUREV0"]=i};return{version:"3.0.1839",setHeaders:(t,s={})=>{var o,r;if(t.headers=i.merge({Accept:"application/json","Content-Type":"application/json","X-EPI2ME-CLIENT":s.user_agent||"api","X-EPI2ME-VERSION":s.agent_version||Ge.version},t.headers,s.headers),(null===(o=s.signing)||void 0===o||o)&&e(t,s),s.proxy){const e=s.proxy.match(/https?:\/\/((\S+):(\S+)@)?(\S+):(\d+)/);if(!e)throw new Error("Failed to parse Proxy URL");const i=e[2],o=e[3],n={host:e[4],port:+e[5]};i&&o&&(n.proxyAuth=`${i}:${o}`);const a=null!==(r=s.log)&&void 0!==r?r:K;s.proxy.match(/^https/)?(a.debug("using HTTPS over HTTPS proxy",JSON.stringify(n)),t.httpsAgent=h.httpsOverHttps({proxy:n})):(a.debug("using HTTPS over HTTP proxy",JSON.stringify(n)),t.httpsAgent=h.httpsOverHttp({proxy:n})),t.proxy=!1}}}})(),Be=f.buildAxiosFetch(l),Ke=new Set(["get","delete","head","options","post","put","patch","link","unlink"]);function Ve({apikey:e,apisecret:t}){return(s,i={})=>{let o;if(i.method&&(r=i.method,!Ke.has(r.toLowerCase())))throw new Error("Invalid method "+i.method);var r;return o=i,Ge.setHeaders(o,{apikey:e,apisecret:t,signing:!0}),Be(s,i)}}const Xe=new p.ApolloLink(e=>{const{apikey:t,apisecret:s,url:i}=e.getContext(),o=Ve({apikey:t,apisecret:s}),r=p.createHttpLink({uri:j(i,"/graphql"),fetch:o,headers:{keys:{apikey:t,apisecret:s}}});return p.execute(r,e)}),Ye=new p.InMemoryCache,Ze=new p.ApolloClient({link:Xe,cache:Ye});class et{constructor(e){this.client=Ze,this.createContext=e=>{const{apikey:t,apisecret:s,url:i}=this.options;return Object.assign({apikey:t,apisecret:s,url:i},e)},this.resetCache=()=>{this.client.resetStore()},this.workflows=this.query(d`
    query allWorkflows($page: Int, $pageSize: Int, $isActive: Int, $orderBy: String, $region: String) {
      allWorkflows(page: $page, pageSize: $pageSize, isActive: $isActive, orderBy: $orderBy, region: $region) {
        ${He}
        results {
          ${"\nidWorkflow\nname\ndescription\nsummary\nrev\n"}
        }
      }
    }
  `),this.workflowPages=async e=>{let t=e,s=await this.workflows({variables:{page:t}});const i=async e=>(t=e,s=await this.workflows({variables:{page:t}}),s);return{data:s,next:()=>i(t+1),previous:()=>i(t-1),first:()=>i(1),last:()=>i(0)}},this.workflow=this.query(d`
    query workflow($idWorkflow: ID!) {
      workflow(idWorkflow: $idWorkflow) {
        ${"\nidWorkflow\nname\ndescription\nsummary\nrev\n"}
      }
    }
   `),this.workflowInstances=this.query(d`
  query allWorkflowInstances($page: Int, $pageSize: Int, $shared: Boolean, $idUser: ID, $orderBy: String) {
    allWorkflowInstances(page: $page, pageSize: $pageSize, shared: $shared, idUser: $idUser, orderBy: $orderBy) {
      ${He}
      results {
        ${Je}
      }
    }
  }
   `),this.workflowInstance=this.query(d`
      query workflowInstance($idWorkflowInstance: ID!) {
        workflowInstance(idWorkflowInstance: $idWorkflowInstance) {
          ${Je}
        }
      }
   `),this.startWorkflow=this.mutate(d`
    mutation startWorkflow(
      $idWorkflow: ID!
      $computeAccountId: ID!
      $storageAccountId: ID
      $isConsentedHuman: Boolean = false
      $idDataset: ID
      $storeResults: Boolean = false
      $userDefined: GenericScalar
      $instanceAttributes: [GenericScalar]
      $region: String
    ) {
      startData: startWorkflowInstance(
        idWorkflow: $idWorkflow
        computeAccountId: $computeAccountId
        storageAccountId: $storageAccountId
        isConsentedHuman: $isConsentedHuman
        idDataset: $idDataset
        storeResults: $storeResults
        userDefined: $userDefined
        instanceAttributes: $instanceAttributes
        region: $region
      ) {
        bucket
        idUser
        remoteAddr
        instance {
          idWorkflowInstance
          chain
          keyId
          outputqueue
          mappedTelemetry
          workflowImage {
            inputqueue
            workflow {
              idWorkflow
            }
            region {
              name
            }
          }
        }
      }
    }
  `),this.stopWorkflow=this.mutate(d`
    mutation stopWorkflowInstance($idWorkflowInstance: ID!) {
      stopData: stopWorkflowInstance(idWorkflowInstance: $idWorkflowInstance) {
        success
        message
      }
    }
  `),this.instanceToken=this.mutate(d`
    mutation getInstanceToken($idWorkflowInstance: ID!) {
      token: getInstanceToken(idWorkflowInstance: $idWorkflowInstance) {
        id_workflow_instance: idWorkflowInstance
        accessKeyId
        secretAccessKey
        sessionToken
        expiration
        region
      }
    }
  `),this.user=this.query(d`
    query user {
      me {
        username
        realname
        useraccountSet {
          idUserAccount
        }
      }
    }
  `),this.updateUser=this.mutate(d`
    mutation updateUser($idRegionPreferred: ID!) {
      updateUser(idRegionPreferred: $idRegionPreferred) {
        idRegionPreferred
      }
    }
  `),this.register=this.mutate(d`
    mutation registerToken($code: String!, $description: String) {
      registerToken(code: $code, description: $description) {
        apikey
        apisecret
        description
      }
    }
  `),this.status=this.query(d`
    query status {
      status {
        portalVersion
        remoteAddr
        serverTime
        minimumAgent
        dbVersion
      }
    }
  `),this.regions=this.query(d`
    query regions {
      regions {
        idRegion
        description
        name
      }
    }
  `);let t=e.url;t=t.replace(/:\/\//,"://graphql."),t=t.replace(/\/$/,"");const{apikey:s,apisecret:i,log:o,local:r,signing:n}=e;this.options={url:t,agent_version:e.agent_version,local:r,user_agent:e.user_agent,signing:n,apikey:s,apisecret:i},this.log=o}query(e){return t=>{var s,i,o;const r=null!==(s=null===t||void 0===t?void 0:t.context)&&void 0!==s?s:{},n=null!==(i=null===t||void 0===t?void 0:t.variables)&&void 0!==i?i:{},a=null!==(o=null===t||void 0===t?void 0:t.options)&&void 0!==o?o:{},l=this.createContext(r);let c;return c="string"===typeof e?d`
          ${e}
        `:"function"===typeof e?d`
          ${e(He)}
        `:e,this.client.query(Object.assign(Object.assign({query:c,variables:n},a),{context:l}))}}mutate(e){return t=>{var s,i,o;const r=null!==(s=null===t||void 0===t?void 0:t.context)&&void 0!==s?s:{},n=null!==(i=null===t||void 0===t?void 0:t.variables)&&void 0!==i?i:{},a=null!==(o=null===t||void 0===t?void 0:t.options)&&void 0!==o?o:{},l=this.createContext(r);let c;return c="string"===typeof e?d`
          ${e}
        `:e,this.client.mutate(Object.assign(Object.assign({mutation:c,variables:n},a),{context:l}))}}async convertONTJWT(e={token_type:"jwt"},t){if("jwt"!==e.token_type&&!e.description)throw new Error("Description required for signature requests");return _e.post("convert-ont",e,Object.assign(Object.assign({},this.options),{log:{debug:B},headers:{"X-ONT-JWT":t}}))}async healthCheck(){return{status:de((await _e.get("/status",Object.assign(Object.assign({},this.options),{log:{debug:B}}))).status)}}}et.NETWORK_ONLY="network-only",et.CACHE_FIRST="cache-first",et.CACHE_AND_NETWORK="cache-and-network",et.CACHE_ONLY="cache-only",et.NO_CACHE="no-cache";const tt=(e,t)=>{const s=["","K","M","G","T","P","E","Z"];let i=t||0,o=e||0;return o>=1e3?(o/=1e3,i+=1,i>=s.length?"???":tt(o,i)):0===i?`${o}${s[i]}`:`${o.toFixed(1)}${s[i]}`};class st{constructor(e){this.allProfileData={},this.defaultEndpoint=process.env.METRICHOR||Oe,e&&(this.allProfileData=i.merge({profiles:{}},e)),this.allProfileData.endpoint&&(this.defaultEndpoint=this.allProfileData.endpoint)}profile(e){return e?i.merge({endpoint:this.defaultEndpoint},i.merge({profiles:{}},this.allProfileData).profiles[e]):{}}profiles(){return Object.keys(this.allProfileData.profiles||{})}}class it{constructor(e){this.cachedResponses=new Map,this.options=e,this.log=this.options.log}async list(e){const t=e.match(/^[a-z_]+/i);if(!t)throw new Error("Failed to parse entity identifier");return pe((await _e.get(e,this.options))[t[0]+"s"])}read(e,t){return _e.get(`${e}/${t}`,this.options)}async user(){return this.options.local?{accounts:[{id_user_account:"none",number:"NONE",name:"None"}]}:_e.get("user",this.options)}async status(){const e=await _e.get("status",this.options);return{agent_url:ne(e.agent_url),agent_version:ne(e.agent_version),db_version:ne(e.db_version),minimum_agent:ne(e.minimum_agent),portal_version:ne(e.portal_version),remote_addr:ne(e.remote_addr),server_time:ne(e.server_time)}}async jwt(){return ne(await _e.post("authenticate",{},Object.assign(Object.assign({},this.options),{handler:async e=>{if(e.headers["x-epi2me-jwt"])return e.headers["x-epi2me-jwt"];throw new Error("failed to fetch JWT")}})))}async instanceToken(e,t){return _e.post("token",i.merge(t,{id_workflow_instance:e}),i.assign({},this.options,{legacy_form:!0}))}async installToken(e){return _e.post("token/install",{id_workflow:e},i.assign({},this.options,{legacy_form:!0}))}attributes(){return this.list("attribute")}async workflows(e){const t=this.list("workflow");if(e)try{e(null,await t)}catch(s){e(s,null)}return t}amiImages(){if(this.options.local)throw new Error("amiImages unsupported in local mode");return this.list("ami_image")}amiImage(e,t){if(this.options.local)throw new Error("ami_image unsupported in local mode");return t instanceof Object?this.updateAmiImage(ne(e),fe(t)):e instanceof Object?_e.post("ami_image",fe(e),this.options):this.read("ami_image",ne(e))}updateAmiImage(e,t){return _e.put("ami_image",e,t,this.options)}createAmiImage(e){return _e.post("ami_image",e,this.options)}readAmiImage(e){return this.read("ami_image",e)}async workflow(e,t,s){if(e&&t&&s instanceof Function)return this.updateWorkflow(ne(e),fe(t),s);if(e&&t instanceof Object&&!(t instanceof Function))return this.updateWorkflow(ne(e),fe(t));if(e instanceof Object&&t instanceof Function)return this.createWorkflow(fe(e),t);if(e instanceof Object&&!t)return this.createWorkflow(fe(e));const o=me(e),r=Se(t);if(!o){const e=new Error("no workflow id specified");return r?r(e):Promise.reject(e)}const n={};try{const e=await this.read("workflow",o);if(e.error)throw new Error(e.error+"");i.merge(n,e)}catch(c){if(this.log.error(`${o}: error fetching workflow ${String(c)}`),r)return void r(c);throw c}i.merge(n,{params:{}});try{const e=await _e.get("workflow/config/"+o,this.options);if(e.error)throw new Error(e.error+"");i.merge(n,e)}catch(c){if(this.log.error(`${o}: error fetching workflow config ${String(c)}`),r)return void r(c);throw c}const a=ie(n.params)?pe(n.params):fe(n.params),l=[...Object.values(a).map(e=>fe(e)).filter(e=>"ajax_dropdown"===e.widget).map(async e=>{if(oe(e))throw new Error("parameter is undefined");const t=fe(e.values),s=fe(t.items),i=ne(t.source).replace("{{EPI2ME_HOST}}","").replace(/&?apikey=\{\{EPI2ME_API_KEY\}\}/,"");let o;try{o=await _e.get(i,this.options)}catch(c){if(this.log.error("failed to fetch "+i),r)return void r(c);throw c}const n=ve(t.data_root),a=function(e,t){if(!re(e))return we(e,t)}(oe(n)?n:o[n],ue);a&&(e.values=a.map(e=>({label:e[he(s.label_key)],value:e[he(s.value_key)]})))})];try{await Promise.all(l),r&&r(null,n)}catch(c){if(this.log.error(`${o}: error fetching config and parameters ${String(c)}`),!r)throw c;r(c)}return n}async updateWorkflow(e,t,s){const i=_e.put("workflow",e,t,this.options);if(s)try{s(null,await i)}catch(o){s(o)}return i}async createWorkflow(e,t){const s=_e.post("workflow",e,this.options);if(t)try{t(null,await s)}catch(i){t(i)}return s}async startWorkflow(e){return _e.post("workflow_instance",e,Object.assign(Object.assign({},this.options),{legacy_form:!0}))}async stopWorkflow(e){return _e.put("workflow_instance/stop",e.toString(),{},Object.assign(Object.assign({},this.options),{legacy_form:!0}))}async workflowInstances(e){if(!e||!e.run_id)return this.list("workflow_instance");return we((await _e.get(`workflow_instance/wi?show=all&columns[0][name]=run_id;columns[0][searchable]=true;columns[0][search][regex]=true;columns[0][search][value]=${e.run_id};`,this.options)).data,fe).map(e=>({id_workflow_instance:e.id_ins,id_workflow:e.id_flo,run_id:e.run_id,description:e.desc,rev:e.rev}))}async workflowInstance(e){return this.read("workflow_instance",e+"")}async workflowConfig(e){return _e.get("workflow/config/"+e,this.options)}async register(e,t){return _e.put("reg",e,{description:t||`${r.userInfo().username}@${r.hostname()}`},i.assign({},this.options,{signing:!1}))}async datasets(e={}){if(Y(e))throw new Error("Unexpected callback instead of query");e.show||(e.show="mine");return we(await this.list("dataset?show="+e.show),fe)}async dataset(e){if(!this.options.local)return this.read("dataset",e);return we(await this.datasets(),fe).find(t=>t.id_dataset===e)}async fetchContent(e){const t=Object.assign(Object.assign({},this.options),{skip_url_mangle:!0,headers:{"Content-Type":""}});let s;try{s=(await _e.head(e,t)).headers.etag;const i=this.cachedResponses.get(e);if(s&&i&&i.etag===s)return i.response}catch(o){this.log.warn(`Failed to HEAD request ${e}: ${String(o)}`)}const i=await _e.get(e,t);return s&&this.cachedResponses.set(e,{etag:s,response:i}),i}}class ot{constructor(e,t){var s;this.debounces=new Set,this.debounceWindow=null!==(s=t.debounceWindow)&&void 0!==s?s:2e3,this.log=t.log,this.initialise(e,t.url)}async initialise(e,t){try{const s=await e.jwt();this.socket=g(t,{transportOptions:{polling:{extraHeaders:{Cookie:"x-epi2me-jwt="+s}}}}),this.socket.on("connect",()=>{this.log.debug("socket ready")})}catch(s){this.log.error("socket connection failed - JWT authentication error")}}debounce(e,t){const s=i.merge(e)._uuid;if(s){if(this.debounces.has(s))return;this.debounces.add(s),setTimeout(()=>{this.debounces.delete(s)},this.debounceWindow)}t&&t(e)}watch(e,t){if(!this.socket)return this.log.debug("socket not ready. requeueing watch on "+e),void setTimeout(()=>{this.watch(e,t)},1e3);this.socket.on(e,e=>this.debounce(e,t))}emit(e,t){if(!this.socket)return this.log.debug("socket not ready. requeueing emit on "+e),void setTimeout(()=>{this.emit(e,t)},1e3);this.log.debug(`socket emit ${e} ${JSON.stringify(t)}`),this.socket.emit(e,t)}}function rt(e,t){const s=setInterval(t,e);return()=>clearInterval(s)}function nt(e,t){const s=setTimeout(t,e);return()=>clearTimeout(s)}class at{constructor(e={}){let t;if(this.stopped=!0,this.uploadState$=new u.BehaviorSubject(!1),this.analyseState$=new u.BehaviorSubject(!1),this.reportState$=new u.BehaviorSubject(!1),this.runningStates$=u.combineLatest(this.uploadState$,this.analyseState$,this.reportState$),this.instanceTelemetry$=new u.BehaviorSubject([]),this.experimentalWorkerStatus$=new u.BehaviorSubject([]),this.states={download:{progress:{bytes:0,total:0,niceSize:0},success:{files:0,bytes:0,reads:0,niceReads:0,niceSize:0},types:{},fail:0,niceTypes:""},upload:{progress:{bytes:0,total:0,niceSize:0},success:{files:0,bytes:0,reads:0,niceReads:0,niceSize:0},types:{},filesCount:0,niceTypes:""},warnings:[]},this.timers={transferTimeouts:{},visibilityIntervals:{}},this.liveStates$=new u.BehaviorSubject(this.states),"string"===typeof e){const s=fe(JSON.parse(e));t=at.parseOptObject(s)}else t=at.parseOptObject(e);this.config={options:t,instance:{id_workflow_instance:t.id_workflow_instance,discoverQueueCache:{},awssettings:{region:t.region}}},this.log=t.log,this.REST=new it(t),this.graphQL=new et(t)}static parseOptObject(e){const t=ne(e.url,Oe),s={agent_version:ne(e.agent_version,_e.version),log:this.resolveLogger(e.log),local:de(e.local,Te),url:ne(e.endpoint,t),region:ne(e.region,je),user_agent:ne(e.user_agent,xe),sessionGrace:ae(e.sessionGrace,Pe),uploadTimeout:ae(e.uploadTimeout,Re),downloadTimeout:ae(e.downloadTimeout,Ae),fileCheckInterval:ae(e.fileCheckInterval,Ce),downloadCheckInterval:ae(e.downloadCheckInterval,Ne),stateCheckInterval:ae(e.stateCheckInterval,qe),inFlightDelay:ae(e.inFlightDelay,Fe),waitTimeSeconds:ae(e.waitTimeSeconds,Me),waitTokenError:ae(e.waitTokenError,We),transferPoolSize:ae(e.transferPoolSize,De),downloadMode:ne(e.downloadMode,ze),filetype:we(e.filetype,ne,Ue),signing:de(e.signing,Le),sampleDirectory:ne(e.sampleDirectory,Qe),useGraphQL:be(e.useGraphQL),apikey:me(e.apikey),apisecret:me(e.apisecret),id_workflow_instance:ve(e.id_workflow_instance),debounceWindow:ye(e.debounceWindow),proxy:me(e.proxy),inputFolders:we(e.inputFolders,ne,[]),outputFolder:me(e.outputFolder),awsAcceleration:me(e.awsAcceleration),agent_address:me(e.agent_address),telemetryCb:Se(e.telemetryCb),dataCb:Se(e.dataCb),remoteShutdownCb:Se(e.remoteShutdownCb)};return e.inputFolder&&s.inputFolders.push(ne(e.inputFolder)),s}static resolveLogger(e){if(!X(e))return V;try{return{info:ge(e.info),debug:ge(e.debug),warn:ge(e.warn),error:ge(e.error)}}catch(t){throw new Error("expected log object to have error, debug, info and warn methods")}}async socket(){if(this.mySocket)return this.mySocket;this.mySocket=new ot(this.REST,this.config.options);const{id_workflow_instance:e}=this.config.instance;return e&&this.mySocket.watch("workflow_instance:state:"+e,e=>{var t,s;const{instance:i}=this.config,o=ke(null===(t=i.chain)||void 0===t?void 0:t.components);if(o){const t=fe(i.summaryTelemetry),r=Object.entries(o).sort((e,t)=>parseInt(e[0],10)-parseInt(t[0],10)),n=ue(e),a=[];for(const[e,i]of r)if(e in n){const o=+e;let r="ROOT";if(0!==o){const e=he(fe(i).wid);r=null!==(s=Object.keys(fe(t[e]))[0])&&void 0!==s?s:"ROOT"}const[l,c,h]=ne(n[e]).split(",").map(e=>Math.max(0,+e));a.push({running:l,complete:c,error:h,step:o,name:r})}this.experimentalWorkerStatus$.next(a)}}),this.mySocket}async realtimeFeedback(e,t){(await this.socket()).emit(e,t)}setTimer(e,t,s){if(this.timers[e])throw new Error(`An interval with the name ${e} has already been created`);this.timers[e]=rt(t,s)}stopTimer(e){const t=this.timers[e];t&&(this.log.debug(`clearing ${e} interval`),t(),delete this.timers[e])}stopTimeout(e,t){const s=this.timers[e][t];s&&(s(),delete this.timers[e][t])}async stopAnalysis(){this.stopUpload(),this.stopped=!0;const{id_workflow_instance:e}=this.config.instance;if(e){try{this.config.options.useGraphQL?await this.graphQL.stopWorkflow({variables:{idWorkflowInstance:e}}):await this.REST.stopWorkflow(e),this.analyseState$.next(!1)}catch(t){throw this.log.error("Error stopping instance: "+String(t)),t}this.log.info(`workflow instance ${e} stopped`)}}stopUpload(){this.log.debug("stopping watchers"),this.stopTimer("stateCheckInterval"),this.stopTimer("fileCheckInterval"),this.uploadState$.next(!1)}async stopEverything(){this.stopAnalysis();for(const e in this.timers.transferTimeouts){this.log.debug("clearing transferTimeout for "+e);const t=this.timers.transferTimeouts[e];t&&t(),delete this.timers.transferTimeouts[e]}for(const e in this.timers.visibilityIntervals){this.log.debug("clearing visibilityInterval for "+e);const t=this.timers.visibilityIntervals[e];t&&t(),delete this.timers.visibilityIntervals[e]}this.downloadWorkerPool&&(this.log.debug("clearing downloadWorkerPool"),await Promise.all(Object.values(this.downloadWorkerPool)),delete this.downloadWorkerPool),this.stopTimer("summaryTelemetryInterval"),this.stopTimer("downloadCheckInterval")}reportProgress(){const{upload:e,download:t}=this.states;this.log.debug({progress:{download:t,upload:e}})}uploadState(e,t,s){var i,o;const r=null!==(i=this.states.upload)&&void 0!==i?i:{progress:{bytes:0,total:0,niceSize:0},success:{files:0,bytes:0,reads:0,niceReads:0,niceSize:0},types:{},filesCount:0,niceTypes:""};"success"===e?this.updateSuccessState(r.success,t,s):"types"===e?this.updateTypesState(r.types,t,s):this.updateProgressState(r.progress,t,s);try{r.success.niceReads=tt(this.states.upload.success.reads)}catch(a){r.success.niceReads=0}try{r.progress.niceSize=tt(null!==(o=r.success.bytes+r.progress.bytes)&&void 0!==o?o:0)}catch(a){r.progress.niceSize=0}try{r.success.niceSize=tt(this.states.upload.success.bytes)}catch(a){r.success.niceSize=0}r.niceTypes=Object.keys(this.states.upload.types||{}).sort().map(e=>`${this.states.upload.types[e]} ${e}`).join(", ");const n=Date.now();(!this.stateReportTime||n-this.stateReportTime>2e3)&&(this.stateReportTime=n,this.reportProgress()),this.liveStates$.next(Object.assign({},this.states))}downloadState(e,t,s){var i,o;const r=null!==(i=this.states.download)&&void 0!==i?i:{progress:{bytes:0,total:0,niceSize:0},success:{files:0,bytes:0,reads:0,niceReads:0,niceSize:0},types:{},fail:0,niceTypes:""};"success"===e?this.updateSuccessState(r.success,t,s):"types"===e?this.updateTypesState(r.types,t,s):this.updateProgressState(r.progress,t,s);try{r.success.niceReads=tt(this.states.upload.success.reads)}catch(a){r.success.niceReads=0}try{r.progress.niceSize=tt(null!==(o=r.success.bytes+r.progress.bytes)&&void 0!==o?o:0)}catch(a){r.progress.niceSize=0}try{r.success.niceSize=tt(this.states.upload.success.bytes)}catch(a){r.success.niceSize=0}r.niceTypes=Object.keys(this.states.upload.types||{}).sort().map(e=>`${this.states.upload.types[e]} ${e}`).join(", ");const n=Date.now();(!this.stateReportTime||n-this.stateReportTime>2e3)&&(this.stateReportTime=n,this.reportProgress()),this.liveStates$.next(Object.assign({},this.states))}updateSuccessState(e,t,s){var i;const o=new Set(["files","bytes","reads"]);for(const r of Object.keys(s)){const n=("incr"===t?1:-1)*(null!==(i=s[r])&&void 0!==i?i:0);if(o.has(r)){const t=r;e[t]=e[t]+n}}}updateTypesState(e,t,s){var i;for(const o of Object.keys(s)){const r=("incr"===t?1:-1)*(null!==(i=s[o])&&void 0!==i?i:0);e[o]=ae(e[o],0)+r}}updateProgressState(e,t,s){var i;const o=new Set(["bytes","total"]);for(const r of Object.keys(s)){const n=("incr"===t?1:-1)*(null!==(i=s[r])&&void 0!==i?i:0);if(o.has(r)){const t=r;e[t]=e[t]+n}}}url(){return this.config.options.url}apikey(){return this.config.options.apikey}attr(e,t){if(!t)return this.config.options[e];switch(e){case"url":case"region":case"user_agent":case"downloadMode":case"sampleDirectory":case"apikey":case"apisecret":this.config.options[e]=ne(t);break;case"id_workflow_instance":case"sessionGrace":case"uploadTimeout":case"fileCheckInterval":case"downloadCheckInterval":case"stateCheckInterval":case"inFlightDelay":case"waitTimeSeconds":case"waitTokenError":case"transferPoolSize":case"debounceWindow":this.config.options[e]=ae(t);break;case"signing":case"useGraphQL":case"local":this.config.options[e]=de(t);break;case"filetype":this.config.options[e]=we(t,ne);break;default:throw new Error('Cannot modify the "log" attribute')}return this}stats(e){return this.states[e]}}function lt(e,t,s){s instanceof Error?e.error(t,s.stack):e.error(t,s)}at.version=_e.version,at.Profile=st,at.REST=it,at.utils=_e;async function ct(e){return s.stat(e).then(e=>({type:"bytes",bytes:e.size}))}const ht=new Map([["fastq",function(e){return new Promise((t,i)=>{let o=1,r=-1,n={size:0};try{n=s.statSync(e)}catch(a){return void i(a)}s.createReadStream(e).on("data",e=>{r=-1,o-=1;do{r=e.indexOf(10,r+1),o+=1}while(-1!==r)}).on("end",()=>t({type:"fastq",bytes:n.size,reads:Math.floor(o/4)})).on("error",i)})}],["fasta",function(e){return new Promise((t,i)=>{let o=1,r=-1,n={size:0};try{n=s.statSync(e)}catch(a){i(a)}s.createReadStream(e).on("data",e=>{r=-1,o-=1;do{r=e.indexOf(62,r+1),o+=1}while(-1!==r)}).on("end",()=>t({type:"fasta",bytes:n.size,sequences:Math.floor((1+o)/2)})).on("error",i)})}],["fastqgz",function(e){return new Promise((t,i)=>{let o=1,r=-1,n={size:0};try{n=s.statSync(e)}catch(l){return void i(l)}const a=w.createGunzip();s.createReadStream(e).pipe(a).on("data",e=>{r=-1,o-=1;do{r=e.indexOf(10,r+1),o+=1}while(-1!==r)}).on("end",()=>t({type:"gz",bytes:n.size,reads:Math.floor(o/4)})).on("error",i)})}],["default",ct]]),ut=ct,dt=new Map([["fq","fastq"],["fa","fasta"]]);async function pt(e){if(oe(e))return{type:"unknown",bytes:NaN};let t=n.extname(e).toLowerCase().replace(/^[.]/,"");const s=dt.get(t);if(s&&(t=s),"gz"===t){t=e.split(".").slice(1).reduce((e,t)=>{var s;return e+(null!==(s=dt.get(t))&&void 0!==s?s:t)},"")}let i=ht.get(t);return i||(i=ut),i(e)}class ft extends st{constructor(e,t){super({}),this.raiseExceptions=!!t,this.prefsFile=e||ft.profilePath(),this.allProfileData={};try{this.allProfileData=i.merge({profiles:{}},s.readJSONSync(this.prefsFile)),this.allProfileData.endpoint&&(this.defaultEndpoint=this.allProfileData.endpoint)}catch(o){if(this.raiseExceptions)throw o}}static profilePath(){return n.join(o.homedir(),".epi2me.json")}profile(e,t){if(e&&t){i.merge(this.allProfileData,{profiles:{[e]:t}});try{s.writeJSONSync(this.prefsFile,this.allProfileData)}catch(o){if(this.raiseExceptions)throw o}}if(e){if(!this.allProfileData.profiles)throw new Error("cannot read property");return i.merge({endpoint:this.defaultEndpoint},this.allProfileData.profiles[e])}return{}}}class gt{constructor({bandwidth:e=1,interval:t=500,start:s=!0}){this.pipeline=[],this.running=[],this.completed=0,this.timer=null,this.bandwidth=e,this.interval=t,s&&this.start()}static MakeQueryablePromise(e){return"isResolved"in e?e:function(e){let t=!0,s=!1,i=!1;return e.then(()=>{t=!1,s=!0},()=>{t=!1,i=!0}),Object.assign(e,{isResolved:()=>s,isRejected:()=>i,isPending:()=>t})}(e)}enqueue(e){this.pipeline.push(e)}start(){this.timer||(this.timer=rt(this.interval,()=>{this.monitorInterval()}))}stop(){this.timer&&(this.timer(),this.timer=null)}state(){return{queued:this.pipeline.length,running:this.running.length,completed:this.completed,state:this.timer?"running":"stopped"}}monitorInterval(){const e=this.running.length;this.running=this.running.filter(e=>e.isPending()),this.completed+=e-this.running.length;const t=this.bandwidth-this.running.length;for(let s=0;s<t;s+=1){const e=this.pipeline.shift();if(!e)return;this.running.push(gt.MakeQueryablePromise(e()))}}}class wt extends it{async workflows(e){if(!this.options.local)return super.workflows(e);const t=n.join(this.options.url,"workflows");let i;try{return i=(await s.readdir(t)).filter(e=>s.statSync(n.join(t,e)).isDirectory()).map(e=>n.join(t,e,"workflow.json")).map(e=>s.readJsonSync(e)),e?e(null,i):i}catch(o){return this.log.warn(o),e?e(undefined,null):Promise.reject(undefined)}}async workflow(e,t,i){if(!this.options.local||!e||"object"===typeof e||i)return super.workflow(e,t,i);const o=n.join(this.options.url,"workflows"),r=n.join(o,e+"","workflow.json");return s.readJSON(r)}async workflowInstances(e,t){if(!this.options.local){if(Y(e)||t)throw new Error("Local workflows cannot accept a callback");return super.workflowInstances(ke(e))}let i,o;if(!e||e instanceof Function||void 0!==t?(i=Se(e),o=t):o=e,o){const e=new Error("querying of local instances unsupported in local mode");return i?i(e):Promise.reject(e)}const r=n.join(this.options.url,"instances");try{let e=await s.readdir(r);return e=e.filter(e=>s.statSync(n.join(r,e)).isDirectory()),e=e.map(e=>{const t=n.join(r,e,"workflow.json");let i;try{i=s.readJsonSync(t)}catch(o){i={id_workflow:"-",description:"-",rev:"0.0"}}return i.id_workflow_instance=e,i.filename=t,i}),i?i(null,e):e}catch(a){return i?i(a):Promise.reject(a)}}async datasets(e,t){let i,o;if(!e||e instanceof Function||void 0!==t?(i=ge(e),o=null!==t&&void 0!==t?t:{}):o=e,o.show||(o.show="mine"),!this.options.local){if(i)throw new Error("Callback is not supported in local mode");return super.datasets(fe(e))}if("mine"!==o.show){const e=new Error("querying of local datasets unsupported in local mode");if(i)return i(e,null);throw e}const r=n.join(this.options.url,"datasets");try{const e=(await s.readdir(r)).filter(e=>s.statSync(n.join(r,e)).isDirectory());let t=0;const o=e.sort().map(e=>(t+=1,{is_reference_dataset:!0,summary:null,dataset_status:{status_label:"Active",status_value:"active"},size:0,prefix:e,id_workflow_instance:null,id_account:null,is_consented_human:null,data_fields:null,component_id:null,uuid:e,is_shared:!1,id_dataset:t,id_user:null,last_modified:null,created:null,name:e,source:e,attributes:null}));return i?i(null,o):o}catch(a){return this.log.warn(a),i?i(null,[]):[]}}async bundleWorkflow(e,t,s){return Ie.pipe(`workflow/bundle/${e}.tar.gz`,t,this.options,s)}}class mt{constructor(){this.experiments={}}async getExperiments({sourceDir:e=Qe,refresh:t=!1}){return Object.keys(this.experiments).length&&!t||await this.updateExperiments(e),this.experiments}async updateExperiments(e=Qe){var t;const s=(new y).withBasePath().withErrors().filter(e=>e.includes("sequencing_summary")).exclude(e=>e.includes("fastq_")).withMaxDepth(3).crawl(e);let i;try{i=await s.withPromise()}catch(o){return}this.experiments={};for(const r of i){const[e,s]=r.split(n.sep).slice(-3),i=/(?<date>[0-9]{8})_(?<time>[0-9]{4})_.*_(?<flowcell>\w+\d+)_\w+/;if(!i.test(s))continue;const{date:o,time:a,flowcell:l}=null===(t=i.exec(s))||void 0===t?void 0:t.groups,c=`${o.slice(0,4)}-${o.slice(4,6)}-${o.slice(6,8)}`,h=`T${a.slice(0,2)}:${a.slice(2,4)}:00`,u=new Date(c+h),d={sample:s,flowcell:l,path:n.dirname(r)+"/fastq_pass"},p=`${u.toDateString()} ${u.toLocaleTimeString()}`,f=this.experiments[e];f?(f.startDate=p,f.samples.push(d)):this.experiments[e]={startDate:p,samples:[d]}}}}class yt{constructor(e,t,s,o,r){if(this.id_workflow_instance=e,this.children=s,this.options=i.merge(o),this.log=this.options.log,this.REST=t,this.graphQL=r,!s||!s.length)throw new Error("must specify children to session")}async session(){var e;if(!(this.sts_expiration&&this.sts_expiration>Date.now())){this.log.debug("new instance token needed");try{let s;if(this.options.useGraphQL){const t={variables:{idWorkflowInstance:this.id_workflow_instance}};s=fe(null===(e=(await this.graphQL.instanceToken(t)).data)||void 0===e?void 0:e.token)}else s=await this.REST.instanceToken(this.id_workflow_instance,this.options);if(!se(s.expiration)&&!(s.expiration instanceof Date))throw new Error("Invalid token expiration type");this.log.debug("allocated new instance token expiring at "+s.expiration),this.sts_expiration=new Date(s.expiration).getTime()-60*parseInt(this.options.sessionGrace||"0",10);const o={};this.options.proxy&&i.merge(o,{httpOptions:{agent:v(this.options.proxy)}}),i.merge(o,{region:this.options.region},s);for(const e of this.children)try{e.config.update(o)}catch(t){this.log.warn(`failed to update config on ${String(e)}: ${String(t)}`)}}catch(s){this.log.warn("failed to fetch instance token: "+String(s))}}}}async function vt(e,t,o,r,a,l){const{maxChunkBytes:c,maxChunkReads:h}=i.merge(t),u=n.dirname(e),d=n.basename(e),p=d.match(/^[^.]+/),f=p?p[0]:"",g=d.replace(f,""),w=n.join(u,f);if(!c&&!h)return o(e).then(()=>({source:e,split:!1,chunks:[e]}));const m=await s.stat(e);if(c&&m.size<c)return o(e).then(()=>({source:e,split:!1,chunks:[e]}));return new Promise(t=>{let n,u,d=0,p=0,f="",m=0,y=0;const v={source:e,split:!0,chunks:[]};let k;const S=[new Promise(e=>{k=e})];b.createInterface({input:a(e)}).on("line",async e=>{p+=1,f+=e,f+="\n",p>=4&&(p=0,(async e=>{if(!m){d+=1,n=`${w}_${d}${g}`;const e=new Promise((e,t)=>{const i=n,a=()=>{o(i).then(()=>{e(i)}).catch(e=>{t(e)}).finally(()=>{s.unlink(i).catch(e=>{r.warn(`Error unlinking chunk ${i}: ${String(e)}`)})})};l?u=l(i,a):(u=s.createWriteStream(i),u.on("close",a))});S.push(e)}m+=1,y+=e.length,u.write(e,()=>{}),(c&&y>=c||h&&m>=h)&&(m=0,y=0,u.end())})(f),f="")}).on("close",()=>{u.end(),k(),Promise.all(S).then(e=>{e.shift(),t(i.merge({chunks:e},v))})}).on("error",t=>{r.error(`Error chunking ${e}: ${String(t)}`)})})}async function bt(e,t,i,o){return vt(e,t,i,o,e=>s.createReadStream(e))}async function kt(e,t,i,o){return vt(e,t,i,o,e=>s.createReadStream(e).pipe(m.createGunzip()),(e,t)=>{const i=s.createWriteStream(e);i.on("close",t);const o=m.createGzip();return o.pipe(i),o})}const St=new WeakSet,_t=()=>{var e;const t=process.env.APPDATA||("darwin"===process.platform?n.join(o.homedir(),"Library/Application Support"):o.homedir());return null!==(e=process.env.EPI2ME_HOME)&&void 0!==e?e:n.join(t,"linux"===process.platform?".epi2me":"EPI2ME")};class Et extends at{constructor(e){super(e),this.REST=new wt(this.config.options),this.SampleReader=new mt,this.uploadsInProgress=[]}async sessionedS3(){return this.sessionManager||(this.sessionManager=this.initSessionManager()),await this.sessionManager.session(),new t.S3({useAccelerateEndpoint:"on"===this.config.options.awsAcceleration})}async sessionedSQS(){return this.sessionManager||(this.sessionManager=this.initSessionManager()),await this.sessionManager.session(),new t.SQS}async deleteMessage(e){try{const t=await this.discoverQueue(me(this.config.instance.outputQueueName));return(await this.sessionedSQS()).deleteMessage({QueueUrl:t,ReceiptHandle:ne(e.ReceiptHandle)}).promise()}catch(t){throw this.log.error("deleteMessage exception: "+String(t)),this.states.download.failure||(this.states.download.failure={}),this.states.download.failure[t]=this.states.download.failure[t]?ae(this.states.download.failure[t])+1:1,t}}async discoverQueue(e=""){if(this.config.instance.discoverQueueCache[e])return ne(this.config.instance.discoverQueueCache[e]);let t;this.log.debug("discovering queue for "+e);try{const s=await this.sessionedSQS();t=await s.getQueueUrl({QueueName:e}).promise()}catch(i){throw this.log.error(`Error: failed to find queue for ${e}: ${String(i)}`),i}const s=ne(t.QueueUrl);return this.log.debug("found queue "+s),this.config.instance.discoverQueueCache[e]=s,s}async queueLength(e){var t;if(!e)throw new Error("no queueURL specified");const s=null===(t=e.match(/([\w\-_]+)$/))||void 0===t?void 0:t[0];this.log.debug("querying queue length of "+s);try{const t=await this.sessionedSQS(),s=await t.getQueueAttributes({QueueUrl:e,AttributeNames:["ApproximateNumberOfMessages"]}).promise();if((null===s||void 0===s?void 0:s.Attributes)&&"ApproximateNumberOfMessages"in s.Attributes){const e=s.Attributes.ApproximateNumberOfMessages;return parseInt(e,10)}}catch(i){throw this.log.error("error in getQueueAttributes "+String(i)),i}throw new Error("unexpected response")}async autoStart(e,t){const s=await this.autoStartGeneric(e,()=>this.REST.startWorkflow(e),t);return this.setClassConfigREST(s),this.autoConfigure(s,t)}async autoStartGQL(e,t){const s=await this.autoStartGeneric(e,()=>this.graphQL.startWorkflow({variables:e}),t);return this.setClassConfigGQL(s),this.autoConfigure(this.config.instance,t)}async autoStartGeneric(e,t,s){let i;this.stopped=!1;try{i=await t(),this.analyseState$.next(!0)}catch(o){const e="Failed to start workflow: "+String(o);throw this.log.warn(e),s&&s(e),o}return this.config.workflow=JSON.parse(JSON.stringify(e)),this.log.info("instance "+JSON.stringify(i)),this.log.info("workflow config "+JSON.stringify(this.config.workflow)),i}async autoJoin(e,t){let s;this.stopped=!1,this.config.instance.id_workflow_instance=e;try{s=await this.REST.workflowInstance(e)}catch(i){const e="Failed to join workflow instance: "+String(i);return this.log.warn(e),t?t(e):Promise.reject(i)}return"stopped"===s.state?(this.log.warn(`workflow ${e} is already stopped`),t?t("could not join workflow"):Promise.reject(new Error("could not join workflow"))):(this.config.workflow=this.config.workflow||{},this.log.debug("instance "+JSON.stringify(s)),this.log.debug("workflow config "+JSON.stringify(this.config.workflow)),this.setClassConfigREST(s),this.autoConfigure(s,t))}setClassConfigGQL(e){var t;const s=null===(t=e.data)||void 0===t?void 0:t.startData,i=null===s||void 0===s?void 0:s.instance,o=null===i||void 0===i?void 0:i.workflowImage,{bucket:r,idUser:n,remoteAddr:a}=null!==s&&void 0!==s?s:{},{outputqueue:l,keyId:c,startDate:h,idWorkflowInstance:u,mappedTelemetry:d}=null!==i&&void 0!==i?i:{},p=k.isString(null===i||void 0===i?void 0:i.chain)?ne(null===i||void 0===i?void 0:i.chain):fe(null===i||void 0===i?void 0:i.chain),f=null===o||void 0===o?void 0:o.region.name,g=ve(null===o||void 0===o?void 0:o.workflow.idWorkflow),w=null===o||void 0===o?void 0:o.inputqueue,m={bucket:me(r),id_user:ve(n),remote_addr:me(a),id_workflow_instance:ve(u),key_id:me(c),start_date:me(h),outputQueueName:me(l),summaryTelemetry:ke(d),inputQueueName:me(w),id_workflow:g,region:ne(f,this.config.options.region),bucketFolder:`${l}/${n}/${u}`,chain:Ie.convertResponseToObject(p)};this.config.instance=Object.assign(Object.assign({},this.config.instance),m)}setClassConfigREST(e){const t=this.config.instance;t.id_workflow_instance=ve(e.id_workflow_instance),t.id_workflow=ve(e.id_workflow),t.remote_addr=me(e.remote_addr),t.key_id=me(e.key_id),t.bucket=me(e.bucket),t.start_date=me(e.start_date),t.id_user=ve(e.id_user),t.inputQueueName=me(e.inputqueue),t.outputQueueName=me(e.outputqueue),t.region=ne(e.region,this.config.options.region),t.bucketFolder=`${e.outputqueue}/${e.id_user}/${e.id_workflow_instance}`,t.summaryTelemetry=ke(e.telemetry),e.chain&&(t.chain=Ie.convertResponseToObject(fe(e.chain)))}initSessionManager(e,s=[]){return new yt(he(this.config.instance.id_workflow_instance),this.REST,[t,...s],Object.assign({sessionGrace:this.config.options.sessionGrace+"",proxy:this.config.options.proxy,region:this.config.instance.region,log:this.log,useGraphQL:this.config.options.useGraphQL},null!==e&&void 0!==e?e:{}),this.graphQL)}async autoConfigure(e,t){if(!this.config.options.inputFolders.length)throw new Error("must set inputFolder");if(!this.config.options.outputFolder)throw new Error("must set outputFolder");if(!this.config.instance.bucketFolder)throw new Error("bucketFolder must be set");if(!this.config.instance.inputQueueName)throw new Error("inputQueueName must be set");if(!this.config.instance.outputQueueName)throw new Error("outputQueueName must be set");s.mkdirpSync(this.config.options.outputFolder);const i=n.join(_t(),"instances"),o=n.join(i,this.config.instance.id_workflow_instance+"");this.db=new $e(o,{idWorkflowInstance:this.config.instance.id_workflow_instance,inputFolders:this.config.options.inputFolders},this.log);const r=this.config.instance.id_workflow_instance?`telemetry-${this.config.instance.id_workflow_instance}.log`:"telemetry.log",a=n.join(this.config.options.outputFolder,"epi2me-logs"),l=n.join(a,r);return s.mkdirp(a,e=>{if(e&&!String(e).match(/EEXIST/))this.log.error("error opening telemetry log stream: mkdirpException:"+String(e));else try{this.telemetryLogStream=s.createWriteStream(l,{flags:"a"}),this.log.info("logging telemetry to "+l)}catch(t){this.log.error("error opening telemetry log stream: "+String(t))}}),t&&t(""),this.timers.summaryTelemetryInterval=rt(1e4*this.config.options.downloadCheckInterval,()=>{if(this.stopped){const e=this.timers.summaryTelemetryInterval;e&&e()}else this.fetchTelemetry()}),this.timers.downloadCheckInterval=rt(1e3*this.config.options.downloadCheckInterval,()=>{if(this.stopped){const e=this.timers.downloadCheckInterval;e&&e()}else this.checkForDownloads()}),this.timers.stateCheckInterval=rt(1e3*this.config.options.stateCheckInterval,async()=>{if(this.stopped){const e=this.timers.stateCheckInterval;e&&e()}else try{let t;if(this.config.options.useGraphQL){const e=await this.graphQL.query("query workflowInstance($idWorkflowInstance: ID!) {\n              instanceObj:workflowInstance(idWorkflowInstance: $idWorkflowInstance) {\n                stop_date: stopDate\n                state\n              }\n            }");t=fe(fe((await e({variables:{idWorkflowInstance:this.config.instance.id_workflow_instance}})).data).instanceObj)}else t=await this.REST.workflowInstance(ae(this.config.instance.id_workflow_instance));if("stopped"===t.state){this.log.warn(`instance was stopped remotely at ${t.stop_date}. shutting down the workflow.`);try{await this.stopEverything();const e=Se(this.config.options.remoteShutdownCb);e&&e("instance was stopped remotely at "+t.stop_date)}catch(e){this.log.error("Error whilst stopping: "+String(e))}}}catch(t){this.log.warn("failed to check instance state: "+((null===t||void 0===t?void 0:t.error)?t.error:t))}}),this.sessionManager=this.initSessionManager(),await this.sessionManager.session(),this.reportProgress(),this.loadUploadFiles(),this.uploadState$.next(!0),this.timers.fileCheckInterval=rt(1e3*this.config.options.fileCheckInterval,this.loadUploadFiles.bind(this)),e}async stopUpload(){for(const e of this.uploadsInProgress)e.abort();this.uploadsInProgress=[],super.stopUpload(),this.log.debug("clearing split files"),this.db&&await this.db.splitClean()}async stopEverything(){delete this.sessionManager,await super.stopEverything()}async checkForDownloads(){if(!this.checkForDownloadsRunning){this.checkForDownloadsRunning=!0,this.log.debug("checkForDownloads checking for downloads");try{const e=await this.discoverQueue(me(this.config.instance.outputQueueName)),t=await this.queueLength(e);t?(this.log.debug("downloads available: "+t),await this.downloadAvailable()):this.log.debug("no downloads available")}catch(e){this.log.warn("checkForDownloads error "+String(e)),this.states.download.failure||(this.states.download.failure={}),this.states.download.failure[e]=this.states.download.failure[e]?ae(this.states.download.failure[e])+1:1}this.checkForDownloadsRunning=!1}}async downloadAvailable(){const e=Object.keys(this.downloadWorkerPool||{}).length;if(e>=this.config.options.transferPoolSize)return void this.log.debug(e+" downloads already queued");let t;try{const s=await this.discoverQueue(me(this.config.instance.outputQueueName));this.log.debug("fetching messages");const i=await this.sessionedSQS();t=await i.receiveMessage({AttributeNames:["All"],QueueUrl:s,VisibilityTimeout:this.config.options.inFlightDelay,MaxNumberOfMessages:this.config.options.transferPoolSize-e,WaitTimeSeconds:this.config.options.waitTimeSeconds}).promise()}catch(s){const e=s.toString();this.log.error("receiveMessage exception: "+e);const t=this.states.download.failure;if(t){const s=t[e];t[e]=ae(s,0)+1}throw s}return this.receiveMessages(t)}async loadUploadFiles(){if(!this.dirScanInProgress){this.dirScanInProgress=!0,this.log.debug("upload: started directory scan");try{const e=async e=>{if(oe(this.db))throw new Error("Database has not been initialized");return function(e){if(Z(e))return e;if(te(e))return 0!==e;if(ee(e))switch(e){case"true":return!0;case"false":return!1}throw new Error(`Unable to cast ${typeof e} to Boolean`)}(await this.db.seenUpload(e))},t=await Ie.loadInputFiles(this.config.options,this.log,e);let s=0;const i=()=>new Promise(e=>{if(this.stopped)return t.length=0,this.log.debug("upload: skipping, stopped"),void e();if(s>this.config.options.transferPoolSize)return void setTimeout(e,1e3);const i=t.splice(0,this.config.options.transferPoolSize-s);s+=i.length,this.enqueueUploadFiles(i).then().catch(e=>{this.log.error("upload: exception in enqueueUploadFiles: "+String(e))}).finally(()=>{s-=i.length,e()})});for(;t.length;)await i()}catch(e){this.log.error("upload: exception in loadInputFiles: "+String(e))}this.dirScanInProgress=!1,this.log.debug("upload: finished directory scan")}}async enqueueUploadFiles(e){let t=0,s=0,i=0,o=0,r={};if(!ie(e)||!e.length)return;this.log.info(`enqueueUploadFiles ${e.length} files: ${e.map(e=>e.path).join(" ")}.`);const a=ke(this.config.workflow);if(a){const e=ke(a.workflow_attributes),t=ke(a.attributes);if(e)r=e;else if(t&&("epi2me:max_size"in t&&(r.max_size=ce(t["epi2me:max_size"])),"epi2me:max_files"in t&&(r.max_files=ce(t["epi2me:max_files"])),"epi2me:split_size"in t&&(r.split_size=ce(t["epi2me:split_size"])),"epi2me:split_reads"in t&&(r.split_reads=ce(t["epi2me:split_reads"])),"epi2me:category"in t)){ne(t["epi2me:category"]).includes("storage")&&(r.requires_storage=!0)}}if(this.log.info("enqueueUploadFiles settings "+JSON.stringify(r)),r.requires_storage){if(!a)throw new Error("Workflow isn't set");if(!("storage_account"in a)){const e={msg:"ERROR: Workflow requires storage enabled. Please provide a valid storage account [ --storage ].",type:"WARNING_STORAGE_ENABLED"};return this.log.error(e.msg),void this.states.warnings.push(e)}}if("split_size"in r&&(i=ce(r.split_size),this.log.info(`enqueueUploadFiles splitting supported files at ${i} bytes`)),"split_reads"in r&&(o=ce(r.split_reads),this.log.info(`enqueueUploadFiles splitting supported files at ${o} reads`)),"max_size"in r&&(s=ce(r.max_size),this.log.info("enqueueUploadFiles restricting file size to "+s)),"max_files"in r&&(t=ce(r.max_files),this.log.info("enqueueUploadFiles restricting file count to "+t),e.length>t)){const s={msg:`ERROR: ${e.length} files found. Workflow can only accept ${t}. Please move the extra files away.`,type:"WARNING_FILE_TOO_MANY"};return this.log.error(s.msg),void this.states.warnings.push(s)}this.states.upload.filesCount+=e.length;const l=e.map(async e=>{var r;if(t&&this.states.upload.filesCount>t){const s=`Maximum ${t} file(s) already uploaded. Marking ${e.relative} as skipped.`,i={msg:s,type:"WARNING_FILE_TOO_MANY"};this.log.error(s),this.states.warnings.push(i),this.states.upload.filesCount-=1,e.skip="SKIP_TOO_MANY"}else if(0===e.size){const t=`The file "${e.relative}" is empty. It will be skipped.`,s={msg:t,type:"WARNING_FILE_EMPTY"};e.skip="SKIP_EMPTY",this.states.upload.filesCount-=1,this.log.error(t),this.states.warnings.push(s)}else{if((null===(r=e.path)||void 0===r?void 0:r.match(/\.(?:fastq|fq)(?:\.gz)?$/))&&(i&&e.size>i||o)){const t=`${e.relative}${e.size>i?" is too big and":""} is going to be split`;this.log.warn(t);const s={msg:t,type:"WARNING_FILE_SPLIT"};this.states.warnings.push(s);const r=i?{maxChunkBytes:i}:{maxChunkReads:o},l=e.path.match(/\.gz$/)?kt:bt,c=Ie.getFileID(),h=new gt({bandwidth:this.config.options.transferPoolSize});let u=0;const d=async t=>{if(this.log.debug("chunkHandler for "+t),!this.db)throw new Error("Database is required but not initialized");if(await this.db.splitFile(t,e.path),this.stopped)return h.stop(),this.log.info("stopped, so skipping "+t),Promise.reject(new Error("stopped"));u+=1;let s=null;for(const e of this.config.options.inputFolders)if(t.includes(e)){s=t.replace(e,"");break}const i=await pt(t),o={name:n.basename(t),path:t,relative:ne(s),id:`${c}_${u}`,stats:i,size:i.bytes},r=new Promise(e=>{h.enqueue(async()=>{if(this.log.info(`chunk upload starting ${o.id} ${o.path}`),this.stopped)return this.log.info(`chunk upload skipped (stopped) ${o.id} ${o.path}`),h.stop(),void e();try{if(await this.uploadJob(o),!this.db)throw new Error("Database is required but not initialized");await this.db.splitDone(o.path)}catch(t){this.log.error(`chunk upload failed ${o.id} ${o.path}: ${String(t)}`)}e()})});await r};try{await l(e.path,r,d,this.log),h.stop()}catch(a){if(h.stop(),"Error: stopped"===String(a))return;throw a}if(!this.db)throw new Error("Database is required but not initialized");return this.db.uploadFile(e.path)}if(s&&e.size>s){const t=`The file "${e.relative}" is bigger than the maximum size limit (${tt(s)}B). It will be skipped.`,i={msg:t,type:"WARNING_FILE_TOO_BIG"};e.skip="SKIP_TOO_BIG",this.states.upload.filesCount-=1,this.log.error(t),this.states.warnings.push(i)}else try{e.stats=await pt(e.path)}catch(l){this.log.error(`failed to stat ${e.path}: ${String(l)}`)}}return this.uploadJob(e)});try{return await Promise.all(l),this.log.info(`upload: inputBatchQueue (${l.length} jobs) complete`),this.loadUploadFiles()}catch(c){throw this.log.error("upload: enqueueUploadFiles exception "+String(c)),c}}async uploadJob(e){var t;if("skip"in e){if(!this.db)throw new Error("Database is required but not initialized");return void await this.db.skipFile(e.path)}let s,i=null;try{this.log.info(`upload: ${e.id} starting`),i=await this.uploadHandler(e),this.log.info(`upload: ${i.id} uploaded and notified`)}catch(o){s=o,this.log.error(`upload: ${e.id} done, but failed: ${String(s)}`)}if(s){if(this.log.error("uploadJob "+s),this.states.upload.failure||(this.states.upload.failure={}),this.states.upload.failure[s]=this.states.upload.failure[s]?ae(this.states.upload.failure[s])+1:1,String(s).match(/AWS.SimpleQueueService.NonExistentQueue/))return this.log.error("instance stopped because of a fatal error"),this.stopEverything()}else{const{bytes:e=0,reads:s=0,sequences:o=0}=null!==(t=null===i||void 0===i?void 0:i.stats)&&void 0!==t?t:{};if(this.uploadState("success","incr",{files:1,bytes:e,reads:s,sequences:o}),null===i||void 0===i?void 0:i.name){const e=n.extname(i.name);this.uploadState("types","incr",{[e]:1})}}}async receiveMessages(e){if(!e||!e.Messages||!e.Messages.length)return void this.log.info("complete (empty)");this.downloadWorkerPool||(this.downloadWorkerPool={});const t=this.downloadWorkerPool;for(const s of e.Messages){const e=le(s.MessageId);t[e]=1;const i=nt(1e3*(60+this.config.options.downloadTimeout),()=>{throw this.log.error("this.downloadWorkerPool timeoutHandle. Clearing queue slot for message: "+s.MessageId),new Error("download timed out")});this.processMessage(s).catch(e=>{this.log.error("processMessage "+String(e))}).finally(()=>{i(),s&&delete t[e]})}this.log.info(`downloader queued ${e.Messages.length} messages for processing`)}async processMessage(e){var t,r,a,l;let c,h;if(!e)return void this.log.debug("download.processMessage: empty message");e.Attributes&&"ApproximateReceiveCount"in e.Attributes&&this.log.debug(`download.processMessage: ${e.MessageId} / ${e.Attributes.ApproximateReceiveCount}`);try{c=JSON.parse(ne(e.Body))}catch(m){this.log.error(`error parsing JSON message.Body from message: ${JSON.stringify(e)} ${String(m)}`);try{await this.deleteMessage(e)}catch(y){this.log.error("Exception deleting message: "+String(y))}return}const u=ke(c.telemetry);if(u){if(u.tm_path)try{this.log.debug(`download.processMessage: ${e.MessageId} fetching telemetry`);const t=await this.sessionedS3(),s=await t.getObject({Bucket:ne(c.bucket),Key:ne(u.tm_path)}).promise();this.log.info(`download.processMessage: ${e.MessageId} fetched telemetry`);const i=s.Body;if(oe(i))throw new Error("Telemetry body is undefined");u.batch=i.toString("utf-8").split("\n").filter(e=>(null===e||void 0===e?void 0:e.length)>0).map(e=>{try{return JSON.parse(e)}catch(y){return this.log.error("Telemetry Batch JSON Parse error: "+String(y)),e}})}catch(v){this.log.error("Could not fetch telemetry JSON: "+String(v))}try{if(!this.telemetryLogStream)throw new Error("Telemetry log stream is not initialized");this.telemetryLogStream.write(JSON.stringify(u)+o.EOL)}catch(b){this.log.error("error writing telemetry: "+b)}this.config.options.telemetryCb&&this.config.options.telemetryCb(u)}if(!c.path)return void this.log.warn("nothing to download");const d=ne(c.path).match(/[\w\W]*\/([\w\W]*?)$/),p=d?d[1]:"",f=this.config.instance.id_workflow_instance;h=n.join(ne(this.config.options.outputFolder),oe(f)?"":le(f));const g=me(null===(t=ke(null===u||void 0===u?void 0:u.hints))||void 0===t?void 0:t.folder);if(g){this.log.debug("using folder hint "+g);const e=g.split("/").map(e=>e.toUpperCase());h=n.join.apply(null,[h,...e])}s.mkdirpSync(h);const w=n.join(h,p);if("data+telemetry"===this.config.options.downloadMode){const t=[""],s=ke(null===(r=this.config.workflow)||void 0===r?void 0:r.settings);let i=we(null===s||void 0===s?void 0:s.output_format,ne,[]);("string"===typeof i||i instanceof String)&&(i=i.trim().split(/[\s,]+/));try{t.push(...i)}catch(y){this.log.error("Failed to work out workflow file suffixes: "+String(y))}try{const s=t.map(t=>{const s=c.path+t,i=w+t;return this.log.debug(`download.processMessage: ${e.MessageId} downloading ${s} to ${i}`),new Promise((o,r)=>{this.initiateDownloadStream({bucket:ne(c.bucket),path:s},e,i).then(o).catch(e=>{this.log.error("Caught exception waiting for initiateDownloadStream: "+String(e)),t?r(e):o()})})});await Promise.all(s)}catch(y){this.log.error("Exception fetching file batch: "+String(y))}try{const e=null!==(a=null===u||void 0===u?void 0:u.json)&&void 0!==a&&a;e&&this.config.options.dataCb&&this.config.options.dataCb(w,e)}catch(v){this.log.warn("failed to fire data callback: "+v)}}else{const e=ke(null===u||void 0===u?void 0:u.batch_summary),t=null!==(l=ye(null===e||void 0===e?void 0:e.reads_num))&&void 0!==l?l:1;this.downloadState("success","incr",{files:1,reads:t})}try{await this.deleteMessage(e)}catch(y){this.log.error("Exception deleting message: "+String(y))}this.realtimeFeedback("workflow_instance:state",{type:"stop",id_workflow_instance:this.config.instance.id_workflow_instance,id_workflow:this.config.instance.id_workflow,component_id:"0",message_id:i.merge(e).MessageId,id_user:this.config.instance.id_user}).catch(e=>{this.log.warn("realtimeFeedback failed: "+String(e))})}async initiateDownloadStream(e,t,i){return new Promise(async(o,r)=>{let a,l,c;try{a=await this.sessionedS3()}catch(d){r(d)}const h=t=>{if(this.log.error(`Error during stream of bucket=${e.bucket} path=${e.path} to file=${i} ${String(t)}`),this.stopTimeout("transferTimeouts",i),!St.has(l))try{St.add(l),l.close(),s.remove(i).then(()=>{this.log.warn("removed failed download "+i)}).catch(e=>{this.log.warn(`failed to remove ${i}. unlinkException: ${String(e)}`)}),c instanceof s.ReadStream&&c.destroy&&(this.log.error("destroying read stream for "+i),c.destroy())}catch(d){this.log.error("error handling stream error: "+String(d))}};try{const t={Bucket:e.bucket,Key:e.path};if(l=s.createWriteStream(i),!a)throw new Error("S3 is required but not initialized");const o=a.getObject(t);o.on("httpHeaders",(e,t)=>{this.downloadState("progress","incr",{total:parseInt(t["content-length"],10)})}),c=o.createReadStream()}catch(p){return this.log.error("getObject/createReadStream exception: "+String(p)),void r(p)}c.on("error",h),l.on("finish",async()=>{if(!St.has(l)){this.log.debug("downloaded "+i);try{const e=n.extname(i),{bytes:t,reads:s,sequences:o}=await pt(i);this.downloadState("success","incr",{files:1,bytes:t,reads:s,sequences:o}),this.downloadState("types","incr",{[e]:1}),this.downloadState("progress","decr",{total:t,bytes:t})}catch(e){this.log.warn(`failed to stat ${i}: ${String(e)}`)}this.reportProgress()}}),l.on("close",s=>{this.log.debug("closing writeStream "+i),s&&this.log.error("error closing write stream "+s);const r=this.timers.visibilityIntervals[i];r&&(r(),delete this.timers.visibilityIntervals[i]);const n=this.timers.transferTimeouts[i];n&&(n(),delete this.timers.transferTimeouts[i]),setTimeout(this.checkForDownloads.bind(this)),this.log.info(`download.initiateDownloadStream: ${t.MessageId} downloaded ${e.path} to ${i}`),o()}),l.on("error",h);const u=()=>{h(new Error("transfer timed out"))};this.timers.transferTimeouts[i]=nt(1e3*this.config.options.downloadTimeout,u);this.timers.visibilityIntervals[i]=rt(900*this.config.options.inFlightDelay,async()=>{if(this.stopped){const e=this.timers.visibilityIntervals[i];e&&(e(),delete this.timers.visibilityIntervals[i])}const e=this.config.instance.outputQueueURL,s=t.ReceiptHandle;this.log.debug({message_id:t.MessageId},"updateVisibility");try{const t=await this.sessionedSQS();await t.changeMessageVisibility({QueueUrl:ne(e),ReceiptHandle:ne(s),VisibilityTimeout:this.config.options.inFlightDelay}).promise()}catch(o){this.log.error({message_id:t.MessageId,queue:e,error:o},"Error setting visibility");const s=this.timers.visibilityIntervals[i];s&&(s(),delete this.timers.visibilityIntervals[i])}}),c.on("data",e=>{const t=this.timers.transferTimeouts[i];t&&t(),this.timers.transferTimeouts[i]=nt(1e3*this.config.options.downloadTimeout,u),this.downloadState("progress","incr",{bytes:e.length})}).pipe(l)})}async uploadHandler(e){const i=await this.sessionedS3();let o,r=!1;const n=e.relative.replace(/^[\\/]+/,"").replace(/\\/g,"/").replace(/\//g,"_"),a=[this.config.instance.bucketFolder,"component-0",n,n].join("/").replace(/\/+/g,"/");let l;return new Promise((n,c)=>{const h=()=>{o&&!r&&o.close(),c(new Error(e.name+" timed out"))};l=nt(1e3*(this.config.options.uploadTimeout+5),h);try{o=s.createReadStream(e.path),o.on("close",()=>{r=!0})}catch(u){return l(),void c(u)}o.on("error",e=>{o.close();let t="error in upload readstream";(null===e||void 0===e?void 0:e.message)&&(t+=": "+e.message),l(),c(new Error(t))}),o.on("open",async()=>{var s;const r={Bucket:ne(this.config.instance.bucket),Key:a,Body:o},u=new t.S3,d={partSize:10485760,queueSize:1,service:u};this.config.instance.key_id&&(r.SSEKMSKeyId=this.config.instance.key_id,r.ServerSideEncryption="aws:kms"),e.size&&(r["Content-Length"]=e.size),this.uploadState("progress","incr",{total:e.size});let p=0;const f=i.upload(r,d);this.uploadsInProgress.push(f);const g=this.initSessionManager(null,[u]);g.sts_expiration=null===(s=this.sessionManager)||void 0===s?void 0:s.sts_expiration,f.on("httpUploadProgress",async e=>{this.uploadState("progress","incr",{bytes:e.loaded-p}),p=e.loaded,l(),l=nt(1e3*(this.config.options.uploadTimeout+5),h);try{await g.session()}catch(t){this.log.warn("Error refreshing token: "+String(t))}});try{await f.promise(),this.log.info(e.id+" S3 upload complete"),o.close(),l(),await this.uploadComplete(a,e),n(e)}catch(w){this.log.warn(`${e.id} uploadStreamError ${w}`),c(w)}finally{this.uploadState("progress","decr",{total:e.size,bytes:e.size}),this.uploadsInProgress=this.uploadsInProgress.filter(e=>e!==f)}})})}async uploadComplete(e,t){this.log.info(`${t.id} uploaded to S3: ${e}`);const s={bucket:this.config.instance.bucket,outputQueue:this.config.instance.outputQueueName,remote_addr:this.config.instance.remote_addr,apikey:this.config.options.apikey,id_workflow_instance:this.config.instance.id_workflow_instance,id_master:this.config.instance.id_workflow,utc:(new Date).toISOString(),path:e,prefix:e.substring(0,e.lastIndexOf("/"))};if(this.config.instance.chain)try{s.components=JSON.parse(JSON.stringify(this.config.instance.chain.components)),s.targetComponentId=this.config.instance.chain.targetComponentId}catch(r){return this.log.error(`${t.id} exception parsing components JSON ${String(r)}`),Promise.reject(r)}if(this.config.instance.key_id&&(s.key_id=this.config.instance.key_id),this.config.options.agent_address)try{s.agent_address=JSON.parse(this.config.options.agent_address)}catch(n){this.log.error(`${t.id} Could not parse agent_address ${String(n)}`)}if(s.components){const e=function(e,t,s){if(re(e)&&"undefined"!==typeof s)return s;if("object"===typeof e&&!1===Array.isArray(e)){const s=fe(e),i={};for(const o in e)i[o]=t(s[o]);return i}throw new Error(`Unable to cast ${typeof e} to Record`)}(s.components,fe);for(const t of Object.values(e))switch(null===t||void 0===t?void 0:t.inputQueueName){case"uploadMessageQueue":t.inputQueueName=this.uploadMessageQueue;break;case"downloadMessageQueue":t.inputQueueName=this.downloadMessageQueue}}let o={};try{const e=await this.discoverQueue(me(this.config.instance.inputQueueName)),i=await this.sessionedSQS();this.log.info(t.id+" sending SQS message to input queue"),o=await i.sendMessage({QueueUrl:e,MessageBody:JSON.stringify(s)}).promise()}catch(a){return this.log.error(`${t.id} exception sending SQS message: ${String(a)}`),Promise.reject(a)}if(this.realtimeFeedback("workflow_instance:state",{type:"start",id_workflow_instance:this.config.instance.id_workflow_instance,id_workflow:this.config.instance.id_workflow,component_id:"0",message_id:i.merge(o).MessageId,id_user:this.config.instance.id_user}).catch(e=>{this.log.warn("realtimeFeedback failed: "+String(e))}),this.log.info(t.id+" SQS message sent. Mark as uploaded"),!this.db)throw new Error("Database has not been instantiated");return this.db.uploadFile(t.path)}async fetchTelemetry(){var e,t;if(!(null===(t=null===(e=this.config)||void 0===e?void 0:e.instance)||void 0===t?void 0:t.summaryTelemetry))return;const i=n.join(_t(),"instances"),o=n.join(i,this.config.instance.id_workflow_instance+""),r=[],a=fe(this.config.instance.summaryTelemetry);Object.keys(a).forEach(e=>{var t;const i=null!==(t=fe(a[e]))&&void 0!==t?t:{};let l=me(i[Object.keys(i)[0]]);if(!l)return;l.startsWith("http")||(l=j(this.config.options.url,l));const c=n.join(o,e+".json");r.push((async()=>{try{const e=await this.REST.fetchContent(l);return s.writeJSONSync(c,e),this.reportState$.next(!0),this.log.debug("fetched telemetry summary "+c),e}catch(e){return this.log.debug("Error fetching telemetry",e),null}})())});try{const e=await Promise.all(r);this.instanceTelemetry$.next(e)}catch(l){this.log.warn("summary telemetry incomplete",l)}}}Et.version=Ie.version,Et.REST=wt,Et.utils=Ie,Et.SessionManager=yt,Et.EPI2ME_HOME=_t(),Et.Profile=ft,Et.Factory=class{constructor(e,t={}){this.runningInstances=new Map,this.EPI2ME=e,this.options=t,this.primary=this.instantiate()}get utils(){return this.EPI2ME.utils}get version(){return this.EPI2ME.version}get log(){return this.primary.log}get REST(){return this.primary.REST}get graphQL(){return this.primary.graphQL}get sampleReader(){return this.primary.SampleReader}reset(e={}){this.options=e,this.runningInstances.clear(),this.primary=this.instantiate()}getRunningInstance(e){return this.runningInstances.get(e)}getAllRunningInstances(){return Array.from(this.runningInstances.values())}instantiate(e={}){return new this.EPI2ME(Object.assign(Object.assign({},this.options),e))}async startRun(e,t){const s=this.instantiate(e);try{const e=he((await s.autoStart(t)).id_workflow_instance);this.runningInstances.set(e,s)}catch(i){lt(this.log,"Experienced error starting",i);try{await s.stopEverything()}catch(o){lt(this.log,"Also experienced error stopping",o)}}return s}async startGQLRun(e,t){const s=this.instantiate(Object.assign(Object.assign({},e),{useGraphQL:!0}));try{const e=await s.autoStartGQL(t),i=he(e.id_workflow_instance);this.runningInstances.set(i,s),this.log.debug(e)}catch(i){lt(this.log,"Experienced error starting",i);try{await s.stopEverything()}catch(o){lt(this.log,"Also experienced error stopping",o)}}return s}},Et.GraphQL=et,module.exports=Et;
