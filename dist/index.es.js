/**
 * Copyright Metrichor Ltd. (An Oxford Nanopore Technologies Company) 2020
 */

import t from"aws-sdk";import e from"fs-extra";import{merge as s,remove as i,assign as o}from"lodash";import n,{homedir as r,EOL as a}from"os";import l from"path";import c from"sqlite";import h from"axios";import u from"crypto";import{httpsOverHttps as d,httpsOverHttp as p}from"tunnel";import{BehaviorSubject as f,combineLatest as g}from"rxjs";import w from"graphql-tag";import{ApolloLink as m,createHttpLink as y,execute as v,InMemoryCache as b,ApolloClient as k}from"@apollo/client/core";import{buildAxiosFetch as S}from"@lifeomic/axios-fetch";import _ from"socket.io-client";import E,{createGunzip as I}from"zlib";import $ from"fdir";import T from"proxy-agent";import O from"readline";import{isString as x}from"util";var j="undefined"!==typeof globalThis?globalThis:"undefined"!==typeof window?window:"undefined"!==typeof global?global:"undefined"!==typeof self?self:{};function P(t,e,s){return t(s={path:e,exports:{},require:function(t,e){return function(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}((void 0===e||null===e)&&s.path)}},s.exports),s.exports}var R=P((function(t,e){!function(s){var i=e&&!e.nodeType&&e,o=t&&!t.nodeType&&t,n="object"==typeof j&&j;n.global!==n&&n.window!==n&&n.self!==n||(s=n);var r,a,l=2147483647,c=/^xn--/,h=/[^\x20-\x7E]/,u=/[\x2E\u3002\uFF0E\uFF61]/g,d={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},p=Math.floor,f=String.fromCharCode;function g(t){throw RangeError(d[t])}function w(t,e){for(var s=t.length,i=[];s--;)i[s]=e(t[s]);return i}function m(t,e){var s=t.split("@"),i="";return s.length>1&&(i=s[0]+"@",t=s[1]),i+w((t=t.replace(u,".")).split("."),e).join(".")}function y(t){for(var e,s,i=[],o=0,n=t.length;o<n;)(e=t.charCodeAt(o++))>=55296&&e<=56319&&o<n?56320==(64512&(s=t.charCodeAt(o++)))?i.push(((1023&e)<<10)+(1023&s)+65536):(i.push(e),o--):i.push(e);return i}function v(t){return w(t,(function(t){var e="";return t>65535&&(e+=f((t-=65536)>>>10&1023|55296),t=56320|1023&t),e+=f(t)})).join("")}function b(t,e){return t+22+75*(t<26)-((0!=e)<<5)}function k(t,e,s){var i=0;for(t=s?p(t/700):t>>1,t+=p(t/e);t>455;i+=36)t=p(t/35);return p(i+36*t/(t+38))}function S(t){var e,s,i,o,n,r,a,c,h,u,d,f=[],w=t.length,m=0,y=128,b=72;for((s=t.lastIndexOf("-"))<0&&(s=0),i=0;i<s;++i)t.charCodeAt(i)>=128&&g("not-basic"),f.push(t.charCodeAt(i));for(o=s>0?s+1:0;o<w;){for(n=m,r=1,a=36;o>=w&&g("invalid-input"),((c=(d=t.charCodeAt(o++))-48<10?d-22:d-65<26?d-65:d-97<26?d-97:36)>=36||c>p((l-m)/r))&&g("overflow"),m+=c*r,!(c<(h=a<=b?1:a>=b+26?26:a-b));a+=36)r>p(l/(u=36-h))&&g("overflow"),r*=u;b=k(m-n,e=f.length+1,0==n),p(m/e)>l-y&&g("overflow"),y+=p(m/e),m%=e,f.splice(m++,0,y)}return v(f)}function _(t){var e,s,i,o,n,r,a,c,h,u,d,w,m,v,S,_=[];for(w=(t=y(t)).length,e=128,s=0,n=72,r=0;r<w;++r)(d=t[r])<128&&_.push(f(d));for(i=o=_.length,o&&_.push("-");i<w;){for(a=l,r=0;r<w;++r)(d=t[r])>=e&&d<a&&(a=d);for(a-e>p((l-s)/(m=i+1))&&g("overflow"),s+=(a-e)*m,e=a,r=0;r<w;++r)if((d=t[r])<e&&++s>l&&g("overflow"),d==e){for(c=s,h=36;!(c<(u=h<=n?1:h>=n+26?26:h-n));h+=36)S=c-u,v=36-u,_.push(f(b(u+S%v,0))),c=p(S/v);_.push(f(b(c,0))),n=k(s,m,i==o),s=0,++i}++s,++e}return _.join("")}if(r={version:"1.3.2",ucs2:{decode:y,encode:v},decode:S,encode:_,toASCII:function(t){return m(t,(function(t){return h.test(t)?"xn--"+_(t):t}))},toUnicode:function(t){return m(t,(function(t){return c.test(t)?S(t.slice(4).toLowerCase()):t}))}},i&&o)if(t.exports==i)o.exports=r;else for(a in r)r.hasOwnProperty(a)&&(i[a]=r[a]);else s.punycode=r}(j)}));function A(t,e){return Object.prototype.hasOwnProperty.call(t,e)}var C=function(t,e,s,i){e=e||"&",s=s||"=";var o={};if("string"!==typeof t||0===t.length)return o;var n=/\+/g;t=t.split(e);var r=1e3;i&&"number"===typeof i.maxKeys&&(r=i.maxKeys);var a=t.length;r>0&&a>r&&(a=r);for(var l=0;l<a;++l){var c,h,u,d,p=t[l].replace(n,"%20"),f=p.indexOf(s);f>=0?(c=p.substr(0,f),h=p.substr(f+1)):(c=p,h=""),u=decodeURIComponent(c),d=decodeURIComponent(h),A(o,u)?Array.isArray(o[u])?o[u].push(d):o[u]=[o[u],d]:o[u]=d}return o},N=function(t){switch(typeof t){case"string":return t;case"boolean":return t?"true":"false";case"number":return isFinite(t)?t:"";default:return""}},F=function(t,e,s,i){return e=e||"&",s=s||"=",null===t&&(t=void 0),"object"===typeof t?Object.keys(t).map((function(i){var o=encodeURIComponent(N(i))+s;return Array.isArray(t[i])?t[i].map((function(t){return o+encodeURIComponent(N(t))})).join(e):o+encodeURIComponent(N(t[i]))})).join(e):i?encodeURIComponent(N(i))+s+encodeURIComponent(N(t)):""},M=P((function(t,e){e.decode=e.parse=C,e.encode=e.stringify=F})),q=function(t,e){return X(t,!1,!0).resolve(e)};function W(){this.protocol=null,this.slashes=null,this.auth=null,this.host=null,this.port=null,this.hostname=null,this.hash=null,this.search=null,this.query=null,this.pathname=null,this.path=null,this.href=null}var D=/^([a-z0-9.+-]+:)/i,U=/:[0-9]*$/,z=["{","}","|","\\","^","`"].concat(["<",">",'"',"`"," ","\r","\n","\t"]),L=["'"].concat(z),Q=["%","/","?",";","#"].concat(L),H=["/","?","#"],J=/^[a-z0-9A-Z_-]{0,63}$/,G=/^([a-z0-9A-Z_-]{0,63})(.*)$/,B={javascript:!0,"javascript:":!0},K={javascript:!0,"javascript:":!0},V={http:!0,https:!0,ftp:!0,gopher:!0,file:!0,"http:":!0,"https:":!0,"ftp:":!0,"gopher:":!0,"file:":!0};function X(t,e,s){if(t&&Z(t)&&t instanceof W)return t;var i=new W;return i.parse(t,e,s),i}function Y(t){return"string"===typeof t}function Z(t){return"object"===typeof t&&null!==t}function tt(t){return null===t}W.prototype.parse=function(t,e,s){if(!Y(t))throw new TypeError("Parameter 'url' must be a string, not "+typeof t);var i=t;i=i.trim();var o=D.exec(i);if(o){var n=(o=o[0]).toLowerCase();this.protocol=n,i=i.substr(o.length)}if(s||o||i.match(/^\/\/[^@\/]+@[^@\/]+/)){var r="//"===i.substr(0,2);!r||o&&K[o]||(i=i.substr(2),this.slashes=!0)}if(!K[o]&&(r||o&&!V[o])){for(var a,l,c=-1,h=0;h<H.length;h++){-1!==(u=i.indexOf(H[h]))&&(-1===c||u<c)&&(c=u)}-1!==(l=-1===c?i.lastIndexOf("@"):i.lastIndexOf("@",c))&&(a=i.slice(0,l),i=i.slice(l+1),this.auth=decodeURIComponent(a)),c=-1;for(h=0;h<Q.length;h++){var u;-1!==(u=i.indexOf(Q[h]))&&(-1===c||u<c)&&(c=u)}-1===c&&(c=i.length),this.host=i.slice(0,c),i=i.slice(c),this.parseHost(),this.hostname=this.hostname||"";var d="["===this.hostname[0]&&"]"===this.hostname[this.hostname.length-1];if(!d)for(var p=this.hostname.split(/\./),f=(h=0,p.length);h<f;h++){var g=p[h];if(g&&!g.match(J)){for(var w="",m=0,y=g.length;m<y;m++)g.charCodeAt(m)>127?w+="x":w+=g[m];if(!w.match(J)){var v=p.slice(0,h),b=p.slice(h+1),k=g.match(G);k&&(v.push(k[1]),b.unshift(k[2])),b.length&&(i="/"+b.join(".")+i),this.hostname=v.join(".");break}}}if(this.hostname.length>255?this.hostname="":this.hostname=this.hostname.toLowerCase(),!d){var S=this.hostname.split("."),_=[];for(h=0;h<S.length;++h){var E=S[h];_.push(E.match(/[^A-Za-z0-9_-]/)?"xn--"+R.encode(E):E)}this.hostname=_.join(".")}var I=this.port?":"+this.port:"",$=this.hostname||"";this.host=$+I,this.href+=this.host,d&&(this.hostname=this.hostname.substr(1,this.hostname.length-2),"/"!==i[0]&&(i="/"+i))}if(!B[n])for(h=0,f=L.length;h<f;h++){var T=L[h],O=encodeURIComponent(T);O===T&&(O=escape(T)),i=i.split(T).join(O)}var x=i.indexOf("#");-1!==x&&(this.hash=i.substr(x),i=i.slice(0,x));var j=i.indexOf("?");if(-1!==j?(this.search=i.substr(j),this.query=i.substr(j+1),e&&(this.query=M.parse(this.query)),i=i.slice(0,j)):e&&(this.search="",this.query={}),i&&(this.pathname=i),V[n]&&this.hostname&&!this.pathname&&(this.pathname="/"),this.pathname||this.search){I=this.pathname||"",E=this.search||"";this.path=I+E}return this.href=this.format(),this},W.prototype.format=function(){var t=this.auth||"";t&&(t=(t=encodeURIComponent(t)).replace(/%3A/i,":"),t+="@");var e=this.protocol||"",s=this.pathname||"",i=this.hash||"",o=!1,n="";this.host?o=t+this.host:this.hostname&&(o=t+(-1===this.hostname.indexOf(":")?this.hostname:"["+this.hostname+"]"),this.port&&(o+=":"+this.port)),this.query&&Z(this.query)&&Object.keys(this.query).length&&(n=M.stringify(this.query));var r=this.search||n&&"?"+n||"";return e&&":"!==e.substr(-1)&&(e+=":"),this.slashes||(!e||V[e])&&!1!==o?(o="//"+(o||""),s&&"/"!==s.charAt(0)&&(s="/"+s)):o||(o=""),i&&"#"!==i.charAt(0)&&(i="#"+i),r&&"?"!==r.charAt(0)&&(r="?"+r),e+o+(s=s.replace(/[?#]/g,(function(t){return encodeURIComponent(t)})))+(r=r.replace("#","%23"))+i},W.prototype.resolve=function(t){return this.resolveObject(X(t,!1,!0)).format()},W.prototype.resolveObject=function(t){if(Y(t)){var e=new W;e.parse(t,!1,!0),t=e}var s=new W;if(Object.keys(this).forEach((function(t){s[t]=this[t]}),this),s.hash=t.hash,""===t.href)return s.href=s.format(),s;if(t.slashes&&!t.protocol)return Object.keys(t).forEach((function(e){"protocol"!==e&&(s[e]=t[e])})),V[s.protocol]&&s.hostname&&!s.pathname&&(s.path=s.pathname="/"),s.href=s.format(),s;if(t.protocol&&t.protocol!==s.protocol){if(!V[t.protocol])return Object.keys(t).forEach((function(e){s[e]=t[e]})),s.href=s.format(),s;if(s.protocol=t.protocol,t.host||K[t.protocol])s.pathname=t.pathname;else{for(var i=(t.pathname||"").split("/");i.length&&!(t.host=i.shift()););t.host||(t.host=""),t.hostname||(t.hostname=""),""!==i[0]&&i.unshift(""),i.length<2&&i.unshift(""),s.pathname=i.join("/")}if(s.search=t.search,s.query=t.query,s.host=t.host||"",s.auth=t.auth,s.hostname=t.hostname||t.host,s.port=t.port,s.pathname||s.search){var o=s.pathname||"",n=s.search||"";s.path=o+n}return s.slashes=s.slashes||t.slashes,s.href=s.format(),s}var r=s.pathname&&"/"===s.pathname.charAt(0),a=t.host||t.pathname&&"/"===t.pathname.charAt(0),l=a||r||s.host&&t.pathname,c=l,h=s.pathname&&s.pathname.split("/")||[],u=(i=t.pathname&&t.pathname.split("/")||[],s.protocol&&!V[s.protocol]);if(u&&(s.hostname="",s.port=null,s.host&&(""===h[0]?h[0]=s.host:h.unshift(s.host)),s.host="",t.protocol&&(t.hostname=null,t.port=null,t.host&&(""===i[0]?i[0]=t.host:i.unshift(t.host)),t.host=null),l=l&&(""===i[0]||""===h[0])),a)s.host=t.host||""===t.host?t.host:s.host,s.hostname=t.hostname||""===t.hostname?t.hostname:s.hostname,s.search=t.search,s.query=t.query,h=i;else if(i.length)h||(h=[]),h.pop(),h=h.concat(i),s.search=t.search,s.query=t.query;else if(null!=t.search){if(u)s.hostname=s.host=h.shift(),(w=!!(s.host&&s.host.indexOf("@")>0)&&s.host.split("@"))&&(s.auth=w.shift(),s.host=s.hostname=w.shift());return s.search=t.search,s.query=t.query,tt(s.pathname)&&tt(s.search)||(s.path=(s.pathname?s.pathname:"")+(s.search?s.search:"")),s.href=s.format(),s}if(!h.length)return s.pathname=null,s.search?s.path="/"+s.search:s.path=null,s.href=s.format(),s;for(var d=h.slice(-1)[0],p=(s.host||t.host)&&("."===d||".."===d)||""===d,f=0,g=h.length;g>=0;g--)"."==(d=h[g])?h.splice(g,1):".."===d?(h.splice(g,1),f++):f&&(h.splice(g,1),f--);if(!l&&!c)for(;f--;f)h.unshift("..");!l||""===h[0]||h[0]&&"/"===h[0].charAt(0)||h.unshift(""),p&&"/"!==h.join("/").substr(-1)&&h.push("");var w,m=""===h[0]||h[0]&&"/"===h[0].charAt(0);u&&(s.hostname=s.host=m?"":h.length?h.shift():"",(w=!!(s.host&&s.host.indexOf("@")>0)&&s.host.split("@"))&&(s.auth=w.shift(),s.host=s.hostname=w.shift()));return(l=l||s.host&&h.length)&&!m&&h.unshift(""),h.length?s.pathname=h.join("/"):(s.pathname=null,s.path=null),tt(s.pathname)&&tt(s.search)||(s.path=(s.pathname?s.pathname:"")+(s.search?s.search:"")),s.auth=t.auth||s.auth,s.slashes=s.slashes||t.slashes,s.href=s.format(),s},W.prototype.parseHost=function(){var t=this.host,e=U.exec(t);e&&(":"!==(e=e[0])&&(this.port=e.substr(1)),t=t.substr(0,t.length-e.length)),t&&(this.hostname=t)};var et="3.0.1839";const st=(...t)=>{},it={debug:st,error:st,info:st,warn:st},ot={info(...t){console.info(`[${(new Date).toISOString()}] INFO:`,...t)},debug(...t){console.debug(`[${(new Date).toISOString()}] DEBUG:`,...t)},warn(...t){console.warn(`[${(new Date).toISOString()}] WARN:`,...t)},error(...t){console.error(`[${(new Date).toISOString()}] ERROR:`,...t)}};function nt(t){return"object"===typeof t&&!1===Array.isArray(t)}function rt(t){return"function"===typeof t}function at(t){return"boolean"===typeof t}function lt(t){return"string"===typeof t}function ct(t){return"number"===typeof t}function ht(t){return"number"===typeof t||"string"===typeof t}function ut(t){return Array.isArray(t)}function dt(t){return"undefined"===typeof t}function pt(t){return null===t||"undefined"===typeof t}function ft(t,e){if(lt(t))return t;if(pt(t)&&"undefined"!==typeof e)return e;throw new Error(`Unable to cast ${typeof t} to String`)}function gt(t,e){if(ct(t))return t;if(pt(t)&&"undefined"!==typeof e)return e;throw new Error(`Unable to cast ${typeof t} to Number`)}function wt(t){if(lt(t))return t;if(ct(t)||at(t))return t.toString();throw new Error(`Unable to cast ${typeof t} to String`)}function mt(t){if(ct(t))return t;if(lt(t)){const e=parseFloat(t);if(!isNaN(e))return e}if(at(t))return+t;throw new Error(`Unable to cast ${typeof t} to Number`)}function yt(t,e){if(ht(t))return t;if(pt(t)&&"undefined"!==typeof e)return e;throw new Error(`Unable to cast ${typeof t} to Index`)}function vt(t,e){if(nt(t))return t;if(pt(t)&&"undefined"!==typeof e)return e;throw new Error(`Unable to cast ${typeof t} to Indexable`)}function bt(t,e){if(at(t))return t;if(pt(t)&&"undefined"!==typeof e)return e;throw new Error(`Unable to cast ${typeof t} to Boolean`)}function kt(t,e){if(ut(t))return t;if(pt(t)&&"undefined"!==typeof e)return e;throw new Error(`Unable to cast ${typeof t} to Array`)}function St(t,e){if(nt(t))return t;if(pt(t)&&"undefined"!==typeof e)return e;throw new Error(`Unable to cast ${typeof t} to Record`)}function _t(t,e){if(rt(t))return t;if(pt(t)&&"undefined"!==typeof e)return e;throw new Error(`Unable to cast ${typeof t} to Function`)}function Et(t,e,s){if(pt(t)&&"undefined"!==typeof s)return s;if(ut(t))return t.map(e);throw new Error(`Unable to cast ${typeof t} to Array`)}function It(t){if(!pt(t))return ft(t)}function $t(t){if(!pt(t))return gt(t)}function Tt(t){if(!pt(t))return yt(t)}function Ot(t){if(!pt(t))return bt(t)}function xt(t){if(!pt(t))return St(t)}function jt(t){if(!pt(t))return _t(t)}h.defaults.validateStatus=t=>t<=504;const Pt=function(){const t={sign:(t,e)=>{var s,i;if(!e)return;if(t.headers||(t.headers={}),!e.apikey)return;if(t.headers["X-EPI2ME-ApiKey"]=e.apikey,!e.apisecret)return;t.headers["X-EPI2ME-SignatureDate"]=(new Date).toISOString(),(null===(s=t.url)||void 0===s?void 0:s.match(/^https:/))&&(t.url=t.url.replace(/:443/,"")),(null===(i=t.url)||void 0===i?void 0:i.match(/^http:/))&&(t.url=t.url.replace(/:80/,""));const o=[t.url,Object.keys(t.headers).sort().filter(t=>t.match(/^x-epi2me/i)).map(e=>`${e}:${t.headers[e]}`).join("\n")].join("\n"),n=u.createHmac("sha1",e.apisecret).update(o).digest("hex");t.headers["X-EPI2ME-SignatureV0"]=n},responseHandler(t){const e=t&&nt(t.data)?t.data:null;if(t&&t.status>=400){let s="Network error "+t.status;throw(null===e||void 0===e?void 0:e.error)&&(s=e.error+""),504===t.status&&(s="Please check your network connection and try again."),new Error(s)}if(!e)throw new Error("unexpected non-json response");if(e.error)throw new Error(e.error+"");return e}};return{version:"3.0.1839",headers(e,s){var i,o;if(e.headers=Object.assign(Object.assign({Accept:"application/json","Content-Type":"application/json","X-EPI2ME-Client":s.user_agent||"api","X-EPI2ME-Version":s.agent_version||Pt.version},e.headers),s.headers),(null===(i=s.signing)||void 0===i||i)&&t.sign(e,s),s.proxy){const t=s.proxy.match(/https?:\/\/((\S+):(\S+)@)?(\S+):(\d+)/);if(!t)throw new Error("Failed to parse Proxy URL");const i=t[2],n=t[3],r={host:t[4],port:parseInt(t[5],10)};i&&n&&(r.proxyAuth=`${i}:${n}`);const a=null!==(o=s.log)&&void 0!==o?o:it;s.proxy.match(/^https/)?(a.debug("using HTTPS over HTTPS proxy",JSON.stringify(r)),e.httpsAgent=d({proxy:r})):(a.debug("using HTTPS over HTTP proxy",JSON.stringify(r)),e.httpsAgent=p({proxy:r})),e.proxy=!1}},async head(t,e){var s;const i={url:this.mangleURL(t,e)};if(this.headers(i,e),!i.url)throw new Error("unreachable: url argument in HEAD was deleted");(null!==(s=e.log)&&void 0!==s?s:it).debug("HEAD",i.url);const o=await h.head(i.url,i);if(o&&o.status>=400){if(504===o.status)throw new Error("Please check your network connection and try again.");throw new Error("Network error "+o.status)}return o},async get(e,s){var i;const o={url:this.mangleURL(e,s)};if(this.headers(o,s),!o.url)throw new Error("unreachable: url argument in GET was deleted");(null!==(i=s.log)&&void 0!==i?i:it).debug("GET",o.url);const n=await h.get(o.url,o);return t.responseHandler(n)},async post(e,s,i){var o;let n=i.url;n=n.replace(/\/+$/,"");const r={url:`${n}/${e.replace(/\/+/g,"/")}`,data:s,headers:{}};i.legacy_form&&this.processLegacyForm(r,s),this.headers(r,i);const{data:a}=r;delete r.data;const l=null!==(o=i.log)&&void 0!==o?o:it;if(!r.url)throw new Error("unreachable: url argument in POST was deleted");l.debug("POST",r.url);const c=await h.post(r.url,a,r);return i.handler?i.handler(c):t.responseHandler(c)},async put(e,s,i,o){var n;let r=o.url;r=r.replace(/\/+$/,"");const a={url:`${r}/${e.replace(/\/+/g,"/")}/${s}`,data:i,headers:{}};o.legacy_form&&this.processLegacyForm(a,i),this.headers(a,o);const{data:l}=a;delete a.data;const c=null!==(n=o.log)&&void 0!==n?n:it;if(!a.url)throw new Error("unreachable: url argument in PUT was deleted");c.debug("PUT",a.url);const u=await h.put(a.url,l,a);return t.responseHandler(u)},mangleURL(t,e){let s=e.url;return e.skip_url_mangle?t:(t="/"+t,s=s.replace(/\/+$/,""),s+(t=t.replace(/\/+/g,"/")))},processLegacyForm(t,e){const s=[],i=Object.assign({json:JSON.stringify(e)},e);Object.keys(i).sort().forEach(t=>{s.push(`${t}=${escape(i[t]+"")}`)}),t.data=s.join("&"),t.headers["Content-Type"]="application/x-www-form-urlencoded"},convertResponseToObject(t){if("object"===typeof t)return t;try{return JSON.parse(t)}catch(e){throw new Error("exception parsing chain JSON "+String(e))}}}}();let Rt=0;const At=Object.assign(Object.assign({},Pt),{async pipe(t,s,i,o){var n;let r=i.url,a="/"+t;r=r.replace(/\/+$/,""),a=a.replace(/\/+/g,"/");const l={url:r+a,headers:{"Accept-Encoding":"gzip",Accept:"application/gzip"}};if(this.headers(l,i),i.proxy){const t=i.proxy.match(/https?:\/\/((\S+):(\S+)@)?(\S+):(\d+)/);if(!t)throw new Error("Failed to parse Proxy URL");const e=t[2],s=t[3],o={host:t[4],port:parseInt(t[5],10)};e&&s&&(o.proxyAuth=`${e}:${s}`);const r=null!==(n=i.log)&&void 0!==n?n:it;i.proxy.match(/^https/)?(r.debug("using HTTPS over HTTPS proxy",JSON.stringify(o)),l.httpsAgent=d({proxy:o})):(r.debug("using HTTPS over HTTP proxy",JSON.stringify(o)),l.httpsAgent=p({proxy:o})),l.proxy=!1}if(o&&(l.onUploadProgress=o),l.responseType="stream",!l.url)throw new Error("unreachable: url argument in PIPE was deleted");const c=await h.get(l.url,l);return new Promise((t,i)=>{const o=e.createWriteStream(s);c.data.pipe(o),o.on("finish",()=>{t(s)}),o.on("error",t=>{i(new Error("writer failed "+String(t)))})})},getFileID:()=>(Rt+=1,"FILE_"+Rt),async lsRecursive(t,s,i){let o=t;const n=e.statSync(s);if(i){if(await i(s,n))return[]}if(n.isDirectory()){const t=await e.readdir(s),n=[];for(const e of t){const t=l.join(s,e);for(const e of await this.lsRecursive(o,t,i))n.push(e)}return n}return n.isFile()&&o===s&&(o=l.dirname(s)),[{name:l.parse(s).base,path:s,relative:s.replace(o,""),size:n.size,id:this.getFileID()}]},async loadInputFiles({inputFolders:t,outputFolder:e,filetype:s},i,o){let n;n=Array.isArray(s)?s:[s],n=n.map(t=>t&&0!==t.indexOf(".")?"."+t:t);const r=async(t,s)=>{const i=l.basename(t),r=[new Promise((e,s)=>"downloads"===i||"skip"===i||"fail"===i||"fastq_fail"===i||"tmp"===i?s(new Error(t+" failed basic filename")):e("basic ok")),new Promise((o,r)=>{const a=n.length?new RegExp(`(?:${n.join("|")})$`):null;return t.split(l.sep).filter(t=>t.match(/^[.]/)).length||e&&i===l.basename(e)||a&&!t.match(a)&&s.isFile()?r(new Error(t+" failed extended filename")):o("extended ok")}),o?new Promise((e,s)=>{o(t).then(i=>i?s(new Error(t+" failed extraFilter")):e("extra ok"))}):Promise.resolve("extra skip")];try{return await Promise.all(r),!1}catch(a){return!0}},a=[];for(const l of t){const t=await this.lsRecursive(l,l,r);a.push(...t.filter(t=>!!t))}return a},stripFile:t=>[l.dirname(t),l.basename(t)]});class Ct{constructor(t,i,o){const n=s({},i);this.options=n,this.log=o;const{idWorkflowInstance:r,inputFolders:a}=n;o.debug(`setting up ${t}/db.sqlite for ${r}`),this.db=e.mkdirp(t).then(()=>(this.log.debug(`opening ${t}/db.sqlite`),c.open(l.join(t,"db.sqlite")).then(async e=>{this.log.debug(`opened ${t}/db.sqlite`),await e.migrate({migrationsPath:l.join(__dirname,"migrations")});const s=a.map(()=>"(?)").join(",");try{return await Promise.all([e.run("INSERT INTO meta (version, idWorkflowInstance) VALUES(?, ?)",et,r),e.run("INSERT INTO folders (folder_path) VALUES "+s,a)]),e}catch(i){return this.log.error(i),Promise.reject(i)}}))).catch(t=>{throw this.log.error(t),t})}async uploadFile(t){const e=await this.db,[s,i]=At.stripFile(t);return await e.run("INSERT OR IGNORE INTO folders (folder_path) VALUES (?)",s),e.run("INSERT INTO uploads(filename, path_id) VALUES(?, (SELECT folder_id FROM folders WHERE folder_path = ?))",i,s)}async skipFile(t){const e=await this.db,[s,i]=At.stripFile(t);return await e.run("INSERT OR IGNORE INTO folders (folder_path) VALUES (?)",s),e.run("INSERT INTO skips(filename, path_id) VALUES(?, (SELECT folder_id FROM folders WHERE folder_path = ?))",i,s)}async splitFile(t,e){const s=await this.db,[i,o]=At.stripFile(t),n=At.stripFile(e)[1];return await s.run("INSERT OR IGNORE INTO folders (folder_path) VALUES (?)",i),s.run("INSERT INTO splits(filename, parent, child_path_id, start, end) VALUES(?, ?, (SELECT folder_id FROM folders WHERE folder_path = ?), CURRENT_TIMESTAMP, NULL)",o,n,i)}async splitDone(t){const e=await this.db,[s,i]=At.stripFile(t);return e.run("UPDATE splits SET end=CURRENT_TIMESTAMP WHERE filename=? AND child_path_id=(SELECT folder_id FROM folders WHERE folder_path=?)",i,s)}async splitClean(){const t=await this.db,s=await t.all("SELECT splits.filename, folders.folder_path FROM splits INNER JOIN folders ON folders.folder_id = splits.child_path_id WHERE end IS NULL");if(!s)return void this.log.info("no split files to clean");this.log.info(`cleaning ${s.length} split files`),this.log.debug("going to clean: "+s.map(t=>t.filename).join(" "));const i=s.map(t=>e.unlink(l.join(t.folder_path,t.filename)).catch(()=>{console.warn("Failed to cleanup "+l.join(t.folder_path,t.filename))}));await Promise.all(i)}async seenUpload(t){const e=await this.db,[s,o]=At.stripFile(t);return Promise.all([e.get("SELECT * FROM uploads u INNER JOIN folders ON folders.folder_id = u.path_id WHERE u.filename=? AND folders.folder_path=? LIMIT 1",[o,s]),e.get("SELECT * FROM skips s INNER JOIN folders ON folders.folder_id = s.path_id WHERE s.filename=? AND folders.folder_path=? LIMIT 1",o,s)]).then(t=>i(t,void 0).length)}}var Nt=!1,Ft="https://epi2me.nanoporetech.com",Mt="EPI2ME API",qt="eu-west-1",Wt=5,Dt=1200,Ut=1200,zt=5,Lt=3,Qt=60,Ht=600,Jt=20,Gt=30,Bt=3,Kt="data+telemetry",Vt=[".fastq",".fq",".fastq.gz",".fq.gz"],Xt=!0,Yt="/data";const Zt="\npage\npages\nhasNext\nhasPrevious\ntotalCount\n",te="\nidWorkflowInstance\nstartDate\nworkflowImage{\n  workflow\n  {\n    rev\n    name\n  }\n}\n",ee=(()=>{const t=(t,e={})=>{if(t.headers||(t.headers={}),!e.apikey||!e.apisecret)return;t.headers["X-EPI2ME-APIKEY"]=e.apikey,t.headers["X-EPI2ME-SIGNATUREDATE"]=(new Date).toISOString();const s=[Object.keys(t.headers).sort().filter(t=>t.match(/^x-epi2me/i)).map(e=>`${e}:${t.headers[e]}`).join("\n"),t.body].join("\n"),i=u.createHmac("sha1",e.apisecret).update(s).digest("hex");t.headers["X-EPI2ME-SIGNATUREV0"]=i};return{version:"3.0.1839",setHeaders:(e,i={})=>{var o,n;if(e.headers=s({Accept:"application/json","Content-Type":"application/json","X-EPI2ME-CLIENT":i.user_agent||"api","X-EPI2ME-VERSION":i.agent_version||ee.version},e.headers,i.headers),(null===(o=i.signing)||void 0===o||o)&&t(e,i),i.proxy){const t=i.proxy.match(/https?:\/\/((\S+):(\S+)@)?(\S+):(\d+)/);if(!t)throw new Error("Failed to parse Proxy URL");const s=t[2],o=t[3],r={host:t[4],port:+t[5]};s&&o&&(r.proxyAuth=`${s}:${o}`);const a=null!==(n=i.log)&&void 0!==n?n:it;i.proxy.match(/^https/)?(a.debug("using HTTPS over HTTPS proxy",JSON.stringify(r)),e.httpsAgent=d({proxy:r})):(a.debug("using HTTPS over HTTP proxy",JSON.stringify(r)),e.httpsAgent=p({proxy:r})),e.proxy=!1}}}})(),se=S(h),ie=new Set(["get","delete","head","options","post","put","patch","link","unlink"]);function oe({apikey:t,apisecret:e}){return(s,i={})=>{let o;if(i.method&&(n=i.method,!ie.has(n.toLowerCase())))throw new Error("Invalid method "+i.method);var n;return o=i,ee.setHeaders(o,{apikey:t,apisecret:e,signing:!0}),se(s,i)}}const ne=new k({link:new m(t=>{const{apikey:e,apisecret:s,url:i}=t.getContext(),o=oe({apikey:e,apisecret:s}),n=y({uri:q(i,"/graphql"),fetch:o,headers:{keys:{apikey:e,apisecret:s}}});return v(n,t)}),cache:new b});class re{constructor(t){this.client=ne,this.createContext=t=>{const{apikey:e,apisecret:s,url:i}=this.options;return Object.assign({apikey:e,apisecret:s,url:i},t)},this.resetCache=()=>{this.client.resetStore()},this.workflows=this.query(w`
    query allWorkflows($page: Int, $pageSize: Int, $isActive: Int, $orderBy: String, $region: String) {
      allWorkflows(page: $page, pageSize: $pageSize, isActive: $isActive, orderBy: $orderBy, region: $region) {
        ${Zt}
        results {
          ${"\nidWorkflow\nname\ndescription\nsummary\nrev\n"}
        }
      }
    }
  `),this.workflowPages=async t=>{let e=t,s=await this.workflows({variables:{page:e}});const i=async t=>(e=t,s=await this.workflows({variables:{page:e}}),s);return{data:s,next:()=>i(e+1),previous:()=>i(e-1),first:()=>i(1),last:()=>i(0)}},this.workflow=this.query(w`
    query workflow($idWorkflow: ID!) {
      workflow(idWorkflow: $idWorkflow) {
        ${"\nidWorkflow\nname\ndescription\nsummary\nrev\n"}
      }
    }
   `),this.workflowInstances=this.query(w`
  query allWorkflowInstances($page: Int, $pageSize: Int, $shared: Boolean, $idUser: ID, $orderBy: String) {
    allWorkflowInstances(page: $page, pageSize: $pageSize, shared: $shared, idUser: $idUser, orderBy: $orderBy) {
      ${Zt}
      results {
        ${te}
      }
    }
  }
   `),this.workflowInstance=this.query(w`
      query workflowInstance($idWorkflowInstance: ID!) {
        workflowInstance(idWorkflowInstance: $idWorkflowInstance) {
          ${te}
        }
      }
   `),this.startWorkflow=this.mutate(w`
    mutation startWorkflow(
      $idWorkflow: ID!
      $computeAccountId: ID!
      $storageAccountId: ID
      $isConsentedHuman: Boolean = false
      $idDataset: ID
      $storeResults: Boolean = false
      $userDefined: GenericScalar
      $instanceAttributes: [GenericScalar]
      $region: String
    ) {
      startData: startWorkflowInstance(
        idWorkflow: $idWorkflow
        computeAccountId: $computeAccountId
        storageAccountId: $storageAccountId
        isConsentedHuman: $isConsentedHuman
        idDataset: $idDataset
        storeResults: $storeResults
        userDefined: $userDefined
        instanceAttributes: $instanceAttributes
        region: $region
      ) {
        bucket
        idUser
        remoteAddr
        instance {
          idWorkflowInstance
          chain
          keyId
          outputqueue
          mappedTelemetry
          workflowImage {
            inputqueue
            workflow {
              idWorkflow
            }
            region {
              name
            }
          }
        }
      }
    }
  `),this.stopWorkflow=this.mutate(w`
    mutation stopWorkflowInstance($idWorkflowInstance: ID!) {
      stopData: stopWorkflowInstance(idWorkflowInstance: $idWorkflowInstance) {
        success
        message
      }
    }
  `),this.instanceToken=this.mutate(w`
    mutation getInstanceToken($idWorkflowInstance: ID!) {
      token: getInstanceToken(idWorkflowInstance: $idWorkflowInstance) {
        id_workflow_instance: idWorkflowInstance
        accessKeyId
        secretAccessKey
        sessionToken
        expiration
        region
      }
    }
  `),this.user=this.query(w`
    query user {
      me {
        username
        realname
        useraccountSet {
          idUserAccount
        }
      }
    }
  `),this.updateUser=this.mutate(w`
    mutation updateUser($idRegionPreferred: ID!) {
      updateUser(idRegionPreferred: $idRegionPreferred) {
        idRegionPreferred
      }
    }
  `),this.register=this.mutate(w`
    mutation registerToken($code: String!, $description: String) {
      registerToken(code: $code, description: $description) {
        apikey
        apisecret
        description
      }
    }
  `),this.status=this.query(w`
    query status {
      status {
        portalVersion
        remoteAddr
        serverTime
        minimumAgent
        dbVersion
      }
    }
  `),this.regions=this.query(w`
    query regions {
      regions {
        idRegion
        description
        name
      }
    }
  `);let e=t.url;e=e.replace(/:\/\//,"://graphql."),e=e.replace(/\/$/,"");const{apikey:s,apisecret:i,log:o,local:n,signing:r}=t;this.options={url:e,agent_version:t.agent_version,local:n,user_agent:t.user_agent,signing:r,apikey:s,apisecret:i},this.log=o}query(t){return e=>{var s,i,o;const n=null!==(s=null===e||void 0===e?void 0:e.context)&&void 0!==s?s:{},r=null!==(i=null===e||void 0===e?void 0:e.variables)&&void 0!==i?i:{},a=null!==(o=null===e||void 0===e?void 0:e.options)&&void 0!==o?o:{},l=this.createContext(n);let c;return c="string"===typeof t?w`
          ${t}
        `:"function"===typeof t?w`
          ${t(Zt)}
        `:t,this.client.query(Object.assign(Object.assign({query:c,variables:r},a),{context:l}))}}mutate(t){return e=>{var s,i,o;const n=null!==(s=null===e||void 0===e?void 0:e.context)&&void 0!==s?s:{},r=null!==(i=null===e||void 0===e?void 0:e.variables)&&void 0!==i?i:{},a=null!==(o=null===e||void 0===e?void 0:e.options)&&void 0!==o?o:{},l=this.createContext(n);let c;return c="string"===typeof t?w`
          ${t}
        `:t,this.client.mutate(Object.assign(Object.assign({mutation:c,variables:r},a),{context:l}))}}async convertONTJWT(t={token_type:"jwt"},e){if("jwt"!==t.token_type&&!t.description)throw new Error("Description required for signature requests");return Pt.post("convert-ont",t,Object.assign(Object.assign({},this.options),{log:{debug:st},headers:{"X-ONT-JWT":e}}))}async healthCheck(){return{status:bt((await Pt.get("/status",Object.assign(Object.assign({},this.options),{log:{debug:st}}))).status)}}}re.NETWORK_ONLY="network-only",re.CACHE_FIRST="cache-first",re.CACHE_AND_NETWORK="cache-and-network",re.CACHE_ONLY="cache-only",re.NO_CACHE="no-cache";const ae=(t,e)=>{const s=["","K","M","G","T","P","E","Z"];let i=e||0,o=t||0;return o>=1e3?(o/=1e3,i+=1,i>=s.length?"???":ae(o,i)):0===i?`${o}${s[i]}`:`${o.toFixed(1)}${s[i]}`};class le{constructor(t){this.allProfileData={},this.defaultEndpoint=process.env.METRICHOR||Ft,t&&(this.allProfileData=s({profiles:{}},t)),this.allProfileData.endpoint&&(this.defaultEndpoint=this.allProfileData.endpoint)}profile(t){return t?s({endpoint:this.defaultEndpoint},s({profiles:{}},this.allProfileData).profiles[t]):{}}profiles(){return Object.keys(this.allProfileData.profiles||{})}}class ce{constructor(t){this.cachedResponses=new Map,this.options=t,this.log=this.options.log}async list(t){const e=t.match(/^[a-z_]+/i);if(!e)throw new Error("Failed to parse entity identifier");return kt((await Pt.get(t,this.options))[e[0]+"s"])}read(t,e){return Pt.get(`${t}/${e}`,this.options)}async user(){return this.options.local?{accounts:[{id_user_account:"none",number:"NONE",name:"None"}]}:Pt.get("user",this.options)}async status(){const t=await Pt.get("status",this.options);return{agent_url:ft(t.agent_url),agent_version:ft(t.agent_version),db_version:ft(t.db_version),minimum_agent:ft(t.minimum_agent),portal_version:ft(t.portal_version),remote_addr:ft(t.remote_addr),server_time:ft(t.server_time)}}async jwt(){return ft(await Pt.post("authenticate",{},Object.assign(Object.assign({},this.options),{handler:async t=>{if(t.headers["x-epi2me-jwt"])return t.headers["x-epi2me-jwt"];throw new Error("failed to fetch JWT")}})))}async instanceToken(t,e){return Pt.post("token",s(e,{id_workflow_instance:t}),o({},this.options,{legacy_form:!0}))}async installToken(t){return Pt.post("token/install",{id_workflow:t},o({},this.options,{legacy_form:!0}))}attributes(){return this.list("attribute")}async workflows(t){const e=this.list("workflow");if(t)try{t(null,await e)}catch(s){t(s,null)}return e}amiImages(){if(this.options.local)throw new Error("amiImages unsupported in local mode");return this.list("ami_image")}amiImage(t,e){if(this.options.local)throw new Error("ami_image unsupported in local mode");return e instanceof Object?this.updateAmiImage(ft(t),St(e)):t instanceof Object?Pt.post("ami_image",St(t),this.options):this.read("ami_image",ft(t))}updateAmiImage(t,e){return Pt.put("ami_image",t,e,this.options)}createAmiImage(t){return Pt.post("ami_image",t,this.options)}readAmiImage(t){return this.read("ami_image",t)}async workflow(t,e,i){if(t&&e&&i instanceof Function)return this.updateWorkflow(ft(t),St(e),i);if(t&&e instanceof Object&&!(e instanceof Function))return this.updateWorkflow(ft(t),St(e));if(t instanceof Object&&e instanceof Function)return this.createWorkflow(St(t),e);if(t instanceof Object&&!e)return this.createWorkflow(St(t));const o=It(t),n=jt(e);if(!o){const t=new Error("no workflow id specified");return n?n(t):Promise.reject(t)}const r={};try{const t=await this.read("workflow",o);if(t.error)throw new Error(t.error+"");s(r,t)}catch(c){if(this.log.error(`${o}: error fetching workflow ${String(c)}`),n)return void n(c);throw c}s(r,{params:{}});try{const t=await Pt.get("workflow/config/"+o,this.options);if(t.error)throw new Error(t.error+"");s(r,t)}catch(c){if(this.log.error(`${o}: error fetching workflow config ${String(c)}`),n)return void n(c);throw c}const a=ut(r.params)?kt(r.params):St(r.params),l=[...Object.values(a).map(t=>St(t)).filter(t=>"ajax_dropdown"===t.widget).map(async t=>{if(dt(t))throw new Error("parameter is undefined");const e=St(t.values),s=St(e.items),i=ft(e.source).replace("{{EPI2ME_HOST}}","").replace(/&?apikey=\{\{EPI2ME_API_KEY\}\}/,"");let o;try{o=await Pt.get(i,this.options)}catch(c){if(this.log.error("failed to fetch "+i),n)return void n(c);throw c}const r=Tt(e.data_root),a=function(t,e){if(!pt(t))return Et(t,e)}(dt(r)?r:o[r],vt);a&&(t.values=a.map(t=>({label:t[yt(s.label_key)],value:t[yt(s.value_key)]})))})];try{await Promise.all(l),n&&n(null,r)}catch(c){if(this.log.error(`${o}: error fetching config and parameters ${String(c)}`),!n)throw c;n(c)}return r}async updateWorkflow(t,e,s){const i=Pt.put("workflow",t,e,this.options);if(s)try{s(null,await i)}catch(o){s(o)}return i}async createWorkflow(t,e){const s=Pt.post("workflow",t,this.options);if(e)try{e(null,await s)}catch(i){e(i)}return s}async startWorkflow(t){return Pt.post("workflow_instance",t,Object.assign(Object.assign({},this.options),{legacy_form:!0}))}async stopWorkflow(t){return Pt.put("workflow_instance/stop",t.toString(),{},Object.assign(Object.assign({},this.options),{legacy_form:!0}))}async workflowInstances(t){if(!t||!t.run_id)return this.list("workflow_instance");return Et((await Pt.get(`workflow_instance/wi?show=all&columns[0][name]=run_id;columns[0][searchable]=true;columns[0][search][regex]=true;columns[0][search][value]=${t.run_id};`,this.options)).data,St).map(t=>({id_workflow_instance:t.id_ins,id_workflow:t.id_flo,run_id:t.run_id,description:t.desc,rev:t.rev}))}async workflowInstance(t){return this.read("workflow_instance",t+"")}async workflowConfig(t){return Pt.get("workflow/config/"+t,this.options)}async register(t,e){return Pt.put("reg",t,{description:e||`${n.userInfo().username}@${n.hostname()}`},o({},this.options,{signing:!1}))}async datasets(t={}){if(rt(t))throw new Error("Unexpected callback instead of query");t.show||(t.show="mine");return Et(await this.list("dataset?show="+t.show),St)}async dataset(t){if(!this.options.local)return this.read("dataset",t);return Et(await this.datasets(),St).find(e=>e.id_dataset===t)}async fetchContent(t){const e=Object.assign(Object.assign({},this.options),{skip_url_mangle:!0,headers:{"Content-Type":""}});let s;try{s=(await Pt.head(t,e)).headers.etag;const i=this.cachedResponses.get(t);if(s&&i&&i.etag===s)return i.response}catch(o){this.log.warn(`Failed to HEAD request ${t}: ${String(o)}`)}const i=await Pt.get(t,e);return s&&this.cachedResponses.set(t,{etag:s,response:i}),i}}class he{constructor(t,e){var s;this.debounces=new Set,this.debounceWindow=null!==(s=e.debounceWindow)&&void 0!==s?s:2e3,this.log=e.log,this.initialise(t,e.url)}async initialise(t,e){try{const s=await t.jwt();this.socket=_(e,{transportOptions:{polling:{extraHeaders:{Cookie:"x-epi2me-jwt="+s}}}}),this.socket.on("connect",()=>{this.log.debug("socket ready")})}catch(s){this.log.error("socket connection failed - JWT authentication error")}}debounce(t,e){const i=s(t)._uuid;if(i){if(this.debounces.has(i))return;this.debounces.add(i),setTimeout(()=>{this.debounces.delete(i)},this.debounceWindow)}e&&e(t)}watch(t,e){if(!this.socket)return this.log.debug("socket not ready. requeueing watch on "+t),void setTimeout(()=>{this.watch(t,e)},1e3);this.socket.on(t,t=>this.debounce(t,e))}emit(t,e){if(!this.socket)return this.log.debug("socket not ready. requeueing emit on "+t),void setTimeout(()=>{this.emit(t,e)},1e3);this.log.debug(`socket emit ${t} ${JSON.stringify(e)}`),this.socket.emit(t,e)}}function ue(t,e){const s=setInterval(e,t);return()=>clearInterval(s)}function de(t,e){const s=setTimeout(e,t);return()=>clearTimeout(s)}class pe{constructor(t={}){let e;if(this.stopped=!0,this.uploadState$=new f(!1),this.analyseState$=new f(!1),this.reportState$=new f(!1),this.runningStates$=g(this.uploadState$,this.analyseState$,this.reportState$),this.instanceTelemetry$=new f([]),this.experimentalWorkerStatus$=new f([]),this.states={download:{progress:{bytes:0,total:0,niceSize:0},success:{files:0,bytes:0,reads:0,niceReads:0,niceSize:0},types:{},fail:0,niceTypes:""},upload:{progress:{bytes:0,total:0,niceSize:0},success:{files:0,bytes:0,reads:0,niceReads:0,niceSize:0},types:{},filesCount:0,niceTypes:""},warnings:[]},this.timers={transferTimeouts:{},visibilityIntervals:{}},this.liveStates$=new f(this.states),"string"===typeof t){const s=St(JSON.parse(t));e=pe.parseOptObject(s)}else e=pe.parseOptObject(t);this.config={options:e,instance:{id_workflow_instance:e.id_workflow_instance,discoverQueueCache:{},awssettings:{region:e.region}}},this.log=e.log,this.REST=new ce(e),this.graphQL=new re(e)}static parseOptObject(t){const e=ft(t.url,Ft),s={agent_version:ft(t.agent_version,Pt.version),log:this.resolveLogger(t.log),local:bt(t.local,Nt),url:ft(t.endpoint,e),region:ft(t.region,qt),user_agent:ft(t.user_agent,Mt),sessionGrace:gt(t.sessionGrace,Wt),uploadTimeout:gt(t.uploadTimeout,Dt),downloadTimeout:gt(t.downloadTimeout,Ut),fileCheckInterval:gt(t.fileCheckInterval,zt),downloadCheckInterval:gt(t.downloadCheckInterval,Lt),stateCheckInterval:gt(t.stateCheckInterval,Qt),inFlightDelay:gt(t.inFlightDelay,Ht),waitTimeSeconds:gt(t.waitTimeSeconds,Jt),waitTokenError:gt(t.waitTokenError,Gt),transferPoolSize:gt(t.transferPoolSize,Bt),downloadMode:ft(t.downloadMode,Kt),filetype:Et(t.filetype,ft,Vt),signing:bt(t.signing,Xt),sampleDirectory:ft(t.sampleDirectory,Yt),useGraphQL:Ot(t.useGraphQL),apikey:It(t.apikey),apisecret:It(t.apisecret),id_workflow_instance:Tt(t.id_workflow_instance),debounceWindow:$t(t.debounceWindow),proxy:It(t.proxy),inputFolders:Et(t.inputFolders,ft,[]),outputFolder:It(t.outputFolder),awsAcceleration:It(t.awsAcceleration),agent_address:It(t.agent_address),telemetryCb:jt(t.telemetryCb),dataCb:jt(t.dataCb),remoteShutdownCb:jt(t.remoteShutdownCb)};return t.inputFolder&&s.inputFolders.push(ft(t.inputFolder)),s}static resolveLogger(t){if(!nt(t))return ot;try{return{info:_t(t.info),debug:_t(t.debug),warn:_t(t.warn),error:_t(t.error)}}catch(e){throw new Error("expected log object to have error, debug, info and warn methods")}}async socket(){if(this.mySocket)return this.mySocket;this.mySocket=new he(this.REST,this.config.options);const{id_workflow_instance:t}=this.config.instance;return t&&this.mySocket.watch("workflow_instance:state:"+t,t=>{var e,s;const{instance:i}=this.config,o=xt(null===(e=i.chain)||void 0===e?void 0:e.components);if(o){const e=St(i.summaryTelemetry),n=Object.entries(o).sort((t,e)=>parseInt(t[0],10)-parseInt(e[0],10)),r=vt(t),a=[];for(const[t,i]of n)if(t in r){const o=+t;let n="ROOT";if(0!==o){const t=yt(St(i).wid);n=null!==(s=Object.keys(St(e[t]))[0])&&void 0!==s?s:"ROOT"}const[l,c,h]=ft(r[t]).split(",").map(t=>Math.max(0,+t));a.push({running:l,complete:c,error:h,step:o,name:n})}this.experimentalWorkerStatus$.next(a)}}),this.mySocket}async realtimeFeedback(t,e){(await this.socket()).emit(t,e)}setTimer(t,e,s){if(this.timers[t])throw new Error(`An interval with the name ${t} has already been created`);this.timers[t]=ue(e,s)}stopTimer(t){const e=this.timers[t];e&&(this.log.debug(`clearing ${t} interval`),e(),delete this.timers[t])}stopTimeout(t,e){const s=this.timers[t][e];s&&(s(),delete this.timers[t][e])}async stopAnalysis(){this.stopUpload(),this.stopped=!0;const{id_workflow_instance:t}=this.config.instance;if(t){try{this.config.options.useGraphQL?await this.graphQL.stopWorkflow({variables:{idWorkflowInstance:t}}):await this.REST.stopWorkflow(t),this.analyseState$.next(!1)}catch(e){throw this.log.error("Error stopping instance: "+String(e)),e}this.log.info(`workflow instance ${t} stopped`)}}stopUpload(){this.log.debug("stopping watchers"),this.stopTimer("stateCheckInterval"),this.stopTimer("fileCheckInterval"),this.uploadState$.next(!1)}async stopEverything(){this.stopAnalysis();for(const t in this.timers.transferTimeouts){this.log.debug("clearing transferTimeout for "+t);const e=this.timers.transferTimeouts[t];e&&e(),delete this.timers.transferTimeouts[t]}for(const t in this.timers.visibilityIntervals){this.log.debug("clearing visibilityInterval for "+t);const e=this.timers.visibilityIntervals[t];e&&e(),delete this.timers.visibilityIntervals[t]}this.downloadWorkerPool&&(this.log.debug("clearing downloadWorkerPool"),await Promise.all(Object.values(this.downloadWorkerPool)),delete this.downloadWorkerPool),this.stopTimer("summaryTelemetryInterval"),this.stopTimer("downloadCheckInterval")}reportProgress(){const{upload:t,download:e}=this.states;this.log.debug({progress:{download:e,upload:t}})}uploadState(t,e,s){var i,o;const n=null!==(i=this.states.upload)&&void 0!==i?i:{progress:{bytes:0,total:0,niceSize:0},success:{files:0,bytes:0,reads:0,niceReads:0,niceSize:0},types:{},filesCount:0,niceTypes:""};"success"===t?this.updateSuccessState(n.success,e,s):"types"===t?this.updateTypesState(n.types,e,s):this.updateProgressState(n.progress,e,s);try{n.success.niceReads=ae(this.states.upload.success.reads)}catch(a){n.success.niceReads=0}try{n.progress.niceSize=ae(null!==(o=n.success.bytes+n.progress.bytes)&&void 0!==o?o:0)}catch(a){n.progress.niceSize=0}try{n.success.niceSize=ae(this.states.upload.success.bytes)}catch(a){n.success.niceSize=0}n.niceTypes=Object.keys(this.states.upload.types||{}).sort().map(t=>`${this.states.upload.types[t]} ${t}`).join(", ");const r=Date.now();(!this.stateReportTime||r-this.stateReportTime>2e3)&&(this.stateReportTime=r,this.reportProgress()),this.liveStates$.next(Object.assign({},this.states))}downloadState(t,e,s){var i,o;const n=null!==(i=this.states.download)&&void 0!==i?i:{progress:{bytes:0,total:0,niceSize:0},success:{files:0,bytes:0,reads:0,niceReads:0,niceSize:0},types:{},fail:0,niceTypes:""};"success"===t?this.updateSuccessState(n.success,e,s):"types"===t?this.updateTypesState(n.types,e,s):this.updateProgressState(n.progress,e,s);try{n.success.niceReads=ae(this.states.upload.success.reads)}catch(a){n.success.niceReads=0}try{n.progress.niceSize=ae(null!==(o=n.success.bytes+n.progress.bytes)&&void 0!==o?o:0)}catch(a){n.progress.niceSize=0}try{n.success.niceSize=ae(this.states.upload.success.bytes)}catch(a){n.success.niceSize=0}n.niceTypes=Object.keys(this.states.upload.types||{}).sort().map(t=>`${this.states.upload.types[t]} ${t}`).join(", ");const r=Date.now();(!this.stateReportTime||r-this.stateReportTime>2e3)&&(this.stateReportTime=r,this.reportProgress()),this.liveStates$.next(Object.assign({},this.states))}updateSuccessState(t,e,s){var i;const o=new Set(["files","bytes","reads"]);for(const n of Object.keys(s)){const r=("incr"===e?1:-1)*(null!==(i=s[n])&&void 0!==i?i:0);if(o.has(n)){const e=n;t[e]=t[e]+r}}}updateTypesState(t,e,s){var i;for(const o of Object.keys(s)){const n=("incr"===e?1:-1)*(null!==(i=s[o])&&void 0!==i?i:0);t[o]=gt(t[o],0)+n}}updateProgressState(t,e,s){var i;const o=new Set(["bytes","total"]);for(const n of Object.keys(s)){const r=("incr"===e?1:-1)*(null!==(i=s[n])&&void 0!==i?i:0);if(o.has(n)){const e=n;t[e]=t[e]+r}}}url(){return this.config.options.url}apikey(){return this.config.options.apikey}attr(t,e){if(!e)return this.config.options[t];switch(t){case"url":case"region":case"user_agent":case"downloadMode":case"sampleDirectory":case"apikey":case"apisecret":this.config.options[t]=ft(e);break;case"id_workflow_instance":case"sessionGrace":case"uploadTimeout":case"fileCheckInterval":case"downloadCheckInterval":case"stateCheckInterval":case"inFlightDelay":case"waitTimeSeconds":case"waitTokenError":case"transferPoolSize":case"debounceWindow":this.config.options[t]=gt(e);break;case"signing":case"useGraphQL":case"local":this.config.options[t]=bt(e);break;case"filetype":this.config.options[t]=Et(e,ft);break;default:throw new Error('Cannot modify the "log" attribute')}return this}stats(t){return this.states[t]}}function fe(t,e,s){s instanceof Error?t.error(e,s.stack):t.error(e,s)}pe.version=Pt.version,pe.Profile=le,pe.REST=ce,pe.utils=Pt;class ge{constructor(t,e={}){this.runningInstances=new Map,this.EPI2ME=t,this.options=e,this.primary=this.instantiate()}get utils(){return this.EPI2ME.utils}get version(){return this.EPI2ME.version}get log(){return this.primary.log}get REST(){return this.primary.REST}get graphQL(){return this.primary.graphQL}get sampleReader(){return this.primary.SampleReader}reset(t={}){this.options=t,this.runningInstances.clear(),this.primary=this.instantiate()}getRunningInstance(t){return this.runningInstances.get(t)}getAllRunningInstances(){return Array.from(this.runningInstances.values())}instantiate(t={}){return new this.EPI2ME(Object.assign(Object.assign({},this.options),t))}async startRun(t,e){const s=this.instantiate(t);try{const t=yt((await s.autoStart(e)).id_workflow_instance);this.runningInstances.set(t,s)}catch(i){fe(this.log,"Experienced error starting",i);try{await s.stopEverything()}catch(o){fe(this.log,"Also experienced error stopping",o)}}return s}async startGQLRun(t,e){const s=this.instantiate(Object.assign(Object.assign({},t),{useGraphQL:!0}));try{const t=await s.autoStartGQL(e),i=yt(t.id_workflow_instance);this.runningInstances.set(i,s),this.log.debug(t)}catch(i){fe(this.log,"Experienced error starting",i);try{await s.stopEverything()}catch(o){fe(this.log,"Also experienced error stopping",o)}}return s}}async function we(t){return e.stat(t).then(t=>({type:"bytes",bytes:t.size}))}const me=new Map([["fastq",function(t){return new Promise((s,i)=>{let o=1,n=-1,r={size:0};try{r=e.statSync(t)}catch(a){return void i(a)}e.createReadStream(t).on("data",t=>{n=-1,o-=1;do{n=t.indexOf(10,n+1),o+=1}while(-1!==n)}).on("end",()=>s({type:"fastq",bytes:r.size,reads:Math.floor(o/4)})).on("error",i)})}],["fasta",function(t){return new Promise((s,i)=>{let o=1,n=-1,r={size:0};try{r=e.statSync(t)}catch(a){i(a)}e.createReadStream(t).on("data",t=>{n=-1,o-=1;do{n=t.indexOf(62,n+1),o+=1}while(-1!==n)}).on("end",()=>s({type:"fasta",bytes:r.size,sequences:Math.floor((1+o)/2)})).on("error",i)})}],["fastqgz",function(t){return new Promise((s,i)=>{let o=1,n=-1,r={size:0};try{r=e.statSync(t)}catch(l){return void i(l)}const a=I();e.createReadStream(t).pipe(a).on("data",t=>{n=-1,o-=1;do{n=t.indexOf(10,n+1),o+=1}while(-1!==n)}).on("end",()=>s({type:"gz",bytes:r.size,reads:Math.floor(o/4)})).on("error",i)})}],["default",we]]),ye=we,ve=new Map([["fq","fastq"],["fa","fasta"]]);async function be(t){if(dt(t))return{type:"unknown",bytes:NaN};let e=l.extname(t).toLowerCase().replace(/^[.]/,"");const s=ve.get(e);if(s&&(e=s),"gz"===e){e=t.split(".").slice(1).reduce((t,e)=>{var s;return t+(null!==(s=ve.get(e))&&void 0!==s?s:e)},"")}let i=me.get(e);return i||(i=ye),i(t)}class ke extends le{constructor(t,i){super({}),this.raiseExceptions=!!i,this.prefsFile=t||ke.profilePath(),this.allProfileData={};try{this.allProfileData=s({profiles:{}},e.readJSONSync(this.prefsFile)),this.allProfileData.endpoint&&(this.defaultEndpoint=this.allProfileData.endpoint)}catch(o){if(this.raiseExceptions)throw o}}static profilePath(){return l.join(r(),".epi2me.json")}profile(t,i){if(t&&i){s(this.allProfileData,{profiles:{[t]:i}});try{e.writeJSONSync(this.prefsFile,this.allProfileData)}catch(o){if(this.raiseExceptions)throw o}}if(t){if(!this.allProfileData.profiles)throw new Error("cannot read property");return s({endpoint:this.defaultEndpoint},this.allProfileData.profiles[t])}return{}}}class Se{constructor({bandwidth:t=1,interval:e=500,start:s=!0}){this.pipeline=[],this.running=[],this.completed=0,this.timer=null,this.bandwidth=t,this.interval=e,s&&this.start()}static MakeQueryablePromise(t){return"isResolved"in t?t:function(t){let e=!0,s=!1,i=!1;return t.then(()=>{e=!1,s=!0},()=>{e=!1,i=!0}),Object.assign(t,{isResolved:()=>s,isRejected:()=>i,isPending:()=>e})}(t)}enqueue(t){this.pipeline.push(t)}start(){this.timer||(this.timer=ue(this.interval,()=>{this.monitorInterval()}))}stop(){this.timer&&(this.timer(),this.timer=null)}state(){return{queued:this.pipeline.length,running:this.running.length,completed:this.completed,state:this.timer?"running":"stopped"}}monitorInterval(){const t=this.running.length;this.running=this.running.filter(t=>t.isPending()),this.completed+=t-this.running.length;const e=this.bandwidth-this.running.length;for(let s=0;s<e;s+=1){const t=this.pipeline.shift();if(!t)return;this.running.push(Se.MakeQueryablePromise(t()))}}}class _e extends ce{async workflows(t){if(!this.options.local)return super.workflows(t);const s=l.join(this.options.url,"workflows");let i;try{return i=(await e.readdir(s)).filter(t=>e.statSync(l.join(s,t)).isDirectory()).map(t=>l.join(s,t,"workflow.json")).map(t=>e.readJsonSync(t)),t?t(null,i):i}catch(o){return this.log.warn(o),t?t(undefined,null):Promise.reject(undefined)}}async workflow(t,s,i){if(!this.options.local||!t||"object"===typeof t||i)return super.workflow(t,s,i);const o=l.join(this.options.url,"workflows"),n=l.join(o,t+"","workflow.json");return e.readJSON(n)}async workflowInstances(t,s){if(!this.options.local){if(rt(t)||s)throw new Error("Local workflows cannot accept a callback");return super.workflowInstances(xt(t))}let i,o;if(!t||t instanceof Function||void 0!==s?(i=jt(t),o=s):o=t,o){const t=new Error("querying of local instances unsupported in local mode");return i?i(t):Promise.reject(t)}const n=l.join(this.options.url,"instances");try{let t=await e.readdir(n);return t=t.filter(t=>e.statSync(l.join(n,t)).isDirectory()),t=t.map(t=>{const s=l.join(n,t,"workflow.json");let i;try{i=e.readJsonSync(s)}catch(o){i={id_workflow:"-",description:"-",rev:"0.0"}}return i.id_workflow_instance=t,i.filename=s,i}),i?i(null,t):t}catch(r){return i?i(r):Promise.reject(r)}}async datasets(t,s){let i,o;if(!t||t instanceof Function||void 0!==s?(i=_t(t),o=null!==s&&void 0!==s?s:{}):o=t,o.show||(o.show="mine"),!this.options.local){if(i)throw new Error("Callback is not supported in local mode");return super.datasets(St(t))}if("mine"!==o.show){const t=new Error("querying of local datasets unsupported in local mode");if(i)return i(t,null);throw t}const n=l.join(this.options.url,"datasets");try{const t=(await e.readdir(n)).filter(t=>e.statSync(l.join(n,t)).isDirectory());let s=0;const o=t.sort().map(t=>(s+=1,{is_reference_dataset:!0,summary:null,dataset_status:{status_label:"Active",status_value:"active"},size:0,prefix:t,id_workflow_instance:null,id_account:null,is_consented_human:null,data_fields:null,component_id:null,uuid:t,is_shared:!1,id_dataset:s,id_user:null,last_modified:null,created:null,name:t,source:t,attributes:null}));return i?i(null,o):o}catch(r){return this.log.warn(r),i?i(null,[]):[]}}async bundleWorkflow(t,e,s){return At.pipe(`workflow/bundle/${t}.tar.gz`,e,this.options,s)}}class Ee{constructor(){this.experiments={}}async getExperiments({sourceDir:t=Yt,refresh:e=!1}){return Object.keys(this.experiments).length&&!e||await this.updateExperiments(t),this.experiments}async updateExperiments(t=Yt){var e;const s=(new $).withBasePath().withErrors().filter(t=>t.includes("sequencing_summary")).exclude(t=>t.includes("fastq_")).withMaxDepth(3).crawl(t);let i;try{i=await s.withPromise()}catch(o){return}this.experiments={};for(const n of i){const[t,s]=n.split(l.sep).slice(-3),i=/(?<date>[0-9]{8})_(?<time>[0-9]{4})_.*_(?<flowcell>\w+\d+)_\w+/;if(!i.test(s))continue;const{date:o,time:r,flowcell:a}=null===(e=i.exec(s))||void 0===e?void 0:e.groups,c=`${o.slice(0,4)}-${o.slice(4,6)}-${o.slice(6,8)}`,h=`T${r.slice(0,2)}:${r.slice(2,4)}:00`,u=new Date(c+h),d={sample:s,flowcell:a,path:l.dirname(n)+"/fastq_pass"},p=`${u.toDateString()} ${u.toLocaleTimeString()}`,f=this.experiments[t];f?(f.startDate=p,f.samples.push(d)):this.experiments[t]={startDate:p,samples:[d]}}}}class Ie{constructor(t,e,i,o,n){if(this.id_workflow_instance=t,this.children=i,this.options=s(o),this.log=this.options.log,this.REST=e,this.graphQL=n,!i||!i.length)throw new Error("must specify children to session")}async session(){var t;if(!(this.sts_expiration&&this.sts_expiration>Date.now())){this.log.debug("new instance token needed");try{let i;if(this.options.useGraphQL){const e={variables:{idWorkflowInstance:this.id_workflow_instance}};i=St(null===(t=(await this.graphQL.instanceToken(e)).data)||void 0===t?void 0:t.token)}else i=await this.REST.instanceToken(this.id_workflow_instance,this.options);if(!ht(i.expiration)&&!(i.expiration instanceof Date))throw new Error("Invalid token expiration type");this.log.debug("allocated new instance token expiring at "+i.expiration),this.sts_expiration=new Date(i.expiration).getTime()-60*parseInt(this.options.sessionGrace||"0",10);const o={};this.options.proxy&&s(o,{httpOptions:{agent:T(this.options.proxy)}}),s(o,{region:this.options.region},i);for(const t of this.children)try{t.config.update(o)}catch(e){this.log.warn(`failed to update config on ${String(t)}: ${String(e)}`)}}catch(i){this.log.warn("failed to fetch instance token: "+String(i))}}}}async function $e(t,i,o,n,r,a){const{maxChunkBytes:c,maxChunkReads:h}=s(i),u=l.dirname(t),d=l.basename(t),p=d.match(/^[^.]+/),f=p?p[0]:"",g=d.replace(f,""),w=l.join(u,f);if(!c&&!h)return o(t).then(()=>({source:t,split:!1,chunks:[t]}));const m=await e.stat(t);if(c&&m.size<c)return o(t).then(()=>({source:t,split:!1,chunks:[t]}));return new Promise(i=>{let l,u,d=0,p=0,f="",m=0,y=0;const v={source:t,split:!0,chunks:[]};let b;const k=[new Promise(t=>{b=t})];O.createInterface({input:r(t)}).on("line",async t=>{p+=1,f+=t,f+="\n",p>=4&&(p=0,(async t=>{if(!m){d+=1,l=`${w}_${d}${g}`;const t=new Promise((t,s)=>{const i=l,r=()=>{o(i).then(()=>{t(i)}).catch(t=>{s(t)}).finally(()=>{e.unlink(i).catch(t=>{n.warn(`Error unlinking chunk ${i}: ${String(t)}`)})})};a?u=a(i,r):(u=e.createWriteStream(i),u.on("close",r))});k.push(t)}m+=1,y+=t.length,u.write(t,()=>{}),(c&&y>=c||h&&m>=h)&&(m=0,y=0,u.end())})(f),f="")}).on("close",()=>{u.end(),b(),Promise.all(k).then(t=>{t.shift(),i(s({chunks:t},v))})}).on("error",e=>{n.error(`Error chunking ${t}: ${String(e)}`)})})}async function Te(t,s,i,o){return $e(t,s,i,o,t=>e.createReadStream(t))}async function Oe(t,s,i,o){return $e(t,s,i,o,t=>e.createReadStream(t).pipe(E.createGunzip()),(t,s)=>{const i=e.createWriteStream(t);i.on("close",s);const o=E.createGzip();return o.pipe(i),o})}const xe=new WeakSet,je=()=>{var t;const e=process.env.APPDATA||("darwin"===process.platform?l.join(r(),"Library/Application Support"):r());return null!==(t=process.env.EPI2ME_HOME)&&void 0!==t?t:l.join(e,"linux"===process.platform?".epi2me":"EPI2ME")};class Pe extends pe{constructor(t){super(t),this.REST=new _e(this.config.options),this.SampleReader=new Ee,this.uploadsInProgress=[]}async sessionedS3(){return this.sessionManager||(this.sessionManager=this.initSessionManager()),await this.sessionManager.session(),new t.S3({useAccelerateEndpoint:"on"===this.config.options.awsAcceleration})}async sessionedSQS(){return this.sessionManager||(this.sessionManager=this.initSessionManager()),await this.sessionManager.session(),new t.SQS}async deleteMessage(t){try{const e=await this.discoverQueue(It(this.config.instance.outputQueueName));return(await this.sessionedSQS()).deleteMessage({QueueUrl:e,ReceiptHandle:ft(t.ReceiptHandle)}).promise()}catch(e){throw this.log.error("deleteMessage exception: "+String(e)),this.states.download.failure||(this.states.download.failure={}),this.states.download.failure[e]=this.states.download.failure[e]?gt(this.states.download.failure[e])+1:1,e}}async discoverQueue(t=""){if(this.config.instance.discoverQueueCache[t])return ft(this.config.instance.discoverQueueCache[t]);let e;this.log.debug("discovering queue for "+t);try{const s=await this.sessionedSQS();e=await s.getQueueUrl({QueueName:t}).promise()}catch(i){throw this.log.error(`Error: failed to find queue for ${t}: ${String(i)}`),i}const s=ft(e.QueueUrl);return this.log.debug("found queue "+s),this.config.instance.discoverQueueCache[t]=s,s}async queueLength(t){var e;if(!t)throw new Error("no queueURL specified");const s=null===(e=t.match(/([\w\-_]+)$/))||void 0===e?void 0:e[0];this.log.debug("querying queue length of "+s);try{const e=await this.sessionedSQS(),s=await e.getQueueAttributes({QueueUrl:t,AttributeNames:["ApproximateNumberOfMessages"]}).promise();if((null===s||void 0===s?void 0:s.Attributes)&&"ApproximateNumberOfMessages"in s.Attributes){const t=s.Attributes.ApproximateNumberOfMessages;return parseInt(t,10)}}catch(i){throw this.log.error("error in getQueueAttributes "+String(i)),i}throw new Error("unexpected response")}async autoStart(t,e){const s=await this.autoStartGeneric(t,()=>this.REST.startWorkflow(t),e);return this.setClassConfigREST(s),this.autoConfigure(s,e)}async autoStartGQL(t,e){const s=await this.autoStartGeneric(t,()=>this.graphQL.startWorkflow({variables:t}),e);return this.setClassConfigGQL(s),this.autoConfigure(this.config.instance,e)}async autoStartGeneric(t,e,s){let i;this.stopped=!1;try{i=await e(),this.analyseState$.next(!0)}catch(o){const t="Failed to start workflow: "+String(o);throw this.log.warn(t),s&&s(t),o}return this.config.workflow=JSON.parse(JSON.stringify(t)),this.log.info("instance "+JSON.stringify(i)),this.log.info("workflow config "+JSON.stringify(this.config.workflow)),i}async autoJoin(t,e){let s;this.stopped=!1,this.config.instance.id_workflow_instance=t;try{s=await this.REST.workflowInstance(t)}catch(i){const t="Failed to join workflow instance: "+String(i);return this.log.warn(t),e?e(t):Promise.reject(i)}return"stopped"===s.state?(this.log.warn(`workflow ${t} is already stopped`),e?e("could not join workflow"):Promise.reject(new Error("could not join workflow"))):(this.config.workflow=this.config.workflow||{},this.log.debug("instance "+JSON.stringify(s)),this.log.debug("workflow config "+JSON.stringify(this.config.workflow)),this.setClassConfigREST(s),this.autoConfigure(s,e))}setClassConfigGQL(t){var e;const s=null===(e=t.data)||void 0===e?void 0:e.startData,i=null===s||void 0===s?void 0:s.instance,o=null===i||void 0===i?void 0:i.workflowImage,{bucket:n,idUser:r,remoteAddr:a}=null!==s&&void 0!==s?s:{},{outputqueue:l,keyId:c,startDate:h,idWorkflowInstance:u,mappedTelemetry:d}=null!==i&&void 0!==i?i:{},p=x(null===i||void 0===i?void 0:i.chain)?ft(null===i||void 0===i?void 0:i.chain):St(null===i||void 0===i?void 0:i.chain),f=null===o||void 0===o?void 0:o.region.name,g=Tt(null===o||void 0===o?void 0:o.workflow.idWorkflow),w=null===o||void 0===o?void 0:o.inputqueue,m={bucket:It(n),id_user:Tt(r),remote_addr:It(a),id_workflow_instance:Tt(u),key_id:It(c),start_date:It(h),outputQueueName:It(l),summaryTelemetry:xt(d),inputQueueName:It(w),id_workflow:g,region:ft(f,this.config.options.region),bucketFolder:`${l}/${r}/${u}`,chain:At.convertResponseToObject(p)};this.config.instance=Object.assign(Object.assign({},this.config.instance),m)}setClassConfigREST(t){const e=this.config.instance;e.id_workflow_instance=Tt(t.id_workflow_instance),e.id_workflow=Tt(t.id_workflow),e.remote_addr=It(t.remote_addr),e.key_id=It(t.key_id),e.bucket=It(t.bucket),e.start_date=It(t.start_date),e.id_user=Tt(t.id_user),e.inputQueueName=It(t.inputqueue),e.outputQueueName=It(t.outputqueue),e.region=ft(t.region,this.config.options.region),e.bucketFolder=`${t.outputqueue}/${t.id_user}/${t.id_workflow_instance}`,e.summaryTelemetry=xt(t.telemetry),t.chain&&(e.chain=At.convertResponseToObject(St(t.chain)))}initSessionManager(e,s=[]){return new Ie(yt(this.config.instance.id_workflow_instance),this.REST,[t,...s],Object.assign({sessionGrace:this.config.options.sessionGrace+"",proxy:this.config.options.proxy,region:this.config.instance.region,log:this.log,useGraphQL:this.config.options.useGraphQL},null!==e&&void 0!==e?e:{}),this.graphQL)}async autoConfigure(t,s){if(!this.config.options.inputFolders.length)throw new Error("must set inputFolder");if(!this.config.options.outputFolder)throw new Error("must set outputFolder");if(!this.config.instance.bucketFolder)throw new Error("bucketFolder must be set");if(!this.config.instance.inputQueueName)throw new Error("inputQueueName must be set");if(!this.config.instance.outputQueueName)throw new Error("outputQueueName must be set");e.mkdirpSync(this.config.options.outputFolder);const i=l.join(je(),"instances"),o=l.join(i,this.config.instance.id_workflow_instance+"");this.db=new Ct(o,{idWorkflowInstance:this.config.instance.id_workflow_instance,inputFolders:this.config.options.inputFolders},this.log);const n=this.config.instance.id_workflow_instance?`telemetry-${this.config.instance.id_workflow_instance}.log`:"telemetry.log",r=l.join(this.config.options.outputFolder,"epi2me-logs"),a=l.join(r,n);return e.mkdirp(r,t=>{if(t&&!String(t).match(/EEXIST/))this.log.error("error opening telemetry log stream: mkdirpException:"+String(t));else try{this.telemetryLogStream=e.createWriteStream(a,{flags:"a"}),this.log.info("logging telemetry to "+a)}catch(s){this.log.error("error opening telemetry log stream: "+String(s))}}),s&&s(""),this.timers.summaryTelemetryInterval=ue(1e4*this.config.options.downloadCheckInterval,()=>{if(this.stopped){const t=this.timers.summaryTelemetryInterval;t&&t()}else this.fetchTelemetry()}),this.timers.downloadCheckInterval=ue(1e3*this.config.options.downloadCheckInterval,()=>{if(this.stopped){const t=this.timers.downloadCheckInterval;t&&t()}else this.checkForDownloads()}),this.timers.stateCheckInterval=ue(1e3*this.config.options.stateCheckInterval,async()=>{if(this.stopped){const t=this.timers.stateCheckInterval;t&&t()}else try{let e;if(this.config.options.useGraphQL){const t=await this.graphQL.query("query workflowInstance($idWorkflowInstance: ID!) {\n              instanceObj:workflowInstance(idWorkflowInstance: $idWorkflowInstance) {\n                stop_date: stopDate\n                state\n              }\n            }");e=St(St((await t({variables:{idWorkflowInstance:this.config.instance.id_workflow_instance}})).data).instanceObj)}else e=await this.REST.workflowInstance(gt(this.config.instance.id_workflow_instance));if("stopped"===e.state){this.log.warn(`instance was stopped remotely at ${e.stop_date}. shutting down the workflow.`);try{await this.stopEverything();const t=jt(this.config.options.remoteShutdownCb);t&&t("instance was stopped remotely at "+e.stop_date)}catch(t){this.log.error("Error whilst stopping: "+String(t))}}}catch(e){this.log.warn("failed to check instance state: "+((null===e||void 0===e?void 0:e.error)?e.error:e))}}),this.sessionManager=this.initSessionManager(),await this.sessionManager.session(),this.reportProgress(),this.loadUploadFiles(),this.uploadState$.next(!0),this.timers.fileCheckInterval=ue(1e3*this.config.options.fileCheckInterval,this.loadUploadFiles.bind(this)),t}async stopUpload(){for(const t of this.uploadsInProgress)t.abort();this.uploadsInProgress=[],super.stopUpload(),this.log.debug("clearing split files"),this.db&&await this.db.splitClean()}async stopEverything(){delete this.sessionManager,await super.stopEverything()}async checkForDownloads(){if(!this.checkForDownloadsRunning){this.checkForDownloadsRunning=!0,this.log.debug("checkForDownloads checking for downloads");try{const t=await this.discoverQueue(It(this.config.instance.outputQueueName)),e=await this.queueLength(t);e?(this.log.debug("downloads available: "+e),await this.downloadAvailable()):this.log.debug("no downloads available")}catch(t){this.log.warn("checkForDownloads error "+String(t)),this.states.download.failure||(this.states.download.failure={}),this.states.download.failure[t]=this.states.download.failure[t]?gt(this.states.download.failure[t])+1:1}this.checkForDownloadsRunning=!1}}async downloadAvailable(){const t=Object.keys(this.downloadWorkerPool||{}).length;if(t>=this.config.options.transferPoolSize)return void this.log.debug(t+" downloads already queued");let e;try{const s=await this.discoverQueue(It(this.config.instance.outputQueueName));this.log.debug("fetching messages");const i=await this.sessionedSQS();e=await i.receiveMessage({AttributeNames:["All"],QueueUrl:s,VisibilityTimeout:this.config.options.inFlightDelay,MaxNumberOfMessages:this.config.options.transferPoolSize-t,WaitTimeSeconds:this.config.options.waitTimeSeconds}).promise()}catch(s){const t=s.toString();this.log.error("receiveMessage exception: "+t);const e=this.states.download.failure;if(e){const s=e[t];e[t]=gt(s,0)+1}throw s}return this.receiveMessages(e)}async loadUploadFiles(){if(!this.dirScanInProgress){this.dirScanInProgress=!0,this.log.debug("upload: started directory scan");try{const t=async t=>{if(dt(this.db))throw new Error("Database has not been initialized");return function(t){if(at(t))return t;if(ct(t))return 0!==t;if(lt(t))switch(t){case"true":return!0;case"false":return!1}throw new Error(`Unable to cast ${typeof t} to Boolean`)}(await this.db.seenUpload(t))},e=await At.loadInputFiles(this.config.options,this.log,t);let s=0;const i=()=>new Promise(t=>{if(this.stopped)return e.length=0,this.log.debug("upload: skipping, stopped"),void t();if(s>this.config.options.transferPoolSize)return void setTimeout(t,1e3);const i=e.splice(0,this.config.options.transferPoolSize-s);s+=i.length,this.enqueueUploadFiles(i).then().catch(t=>{this.log.error("upload: exception in enqueueUploadFiles: "+String(t))}).finally(()=>{s-=i.length,t()})});for(;e.length;)await i()}catch(t){this.log.error("upload: exception in loadInputFiles: "+String(t))}this.dirScanInProgress=!1,this.log.debug("upload: finished directory scan")}}async enqueueUploadFiles(t){let e=0,s=0,i=0,o=0,n={};if(!ut(t)||!t.length)return;this.log.info(`enqueueUploadFiles ${t.length} files: ${t.map(t=>t.path).join(" ")}.`);const r=xt(this.config.workflow);if(r){const t=xt(r.workflow_attributes),e=xt(r.attributes);if(t)n=t;else if(e&&("epi2me:max_size"in e&&(n.max_size=mt(e["epi2me:max_size"])),"epi2me:max_files"in e&&(n.max_files=mt(e["epi2me:max_files"])),"epi2me:split_size"in e&&(n.split_size=mt(e["epi2me:split_size"])),"epi2me:split_reads"in e&&(n.split_reads=mt(e["epi2me:split_reads"])),"epi2me:category"in e)){ft(e["epi2me:category"]).includes("storage")&&(n.requires_storage=!0)}}if(this.log.info("enqueueUploadFiles settings "+JSON.stringify(n)),n.requires_storage){if(!r)throw new Error("Workflow isn't set");if(!("storage_account"in r)){const t={msg:"ERROR: Workflow requires storage enabled. Please provide a valid storage account [ --storage ].",type:"WARNING_STORAGE_ENABLED"};return this.log.error(t.msg),void this.states.warnings.push(t)}}if("split_size"in n&&(i=mt(n.split_size),this.log.info(`enqueueUploadFiles splitting supported files at ${i} bytes`)),"split_reads"in n&&(o=mt(n.split_reads),this.log.info(`enqueueUploadFiles splitting supported files at ${o} reads`)),"max_size"in n&&(s=mt(n.max_size),this.log.info("enqueueUploadFiles restricting file size to "+s)),"max_files"in n&&(e=mt(n.max_files),this.log.info("enqueueUploadFiles restricting file count to "+e),t.length>e)){const s={msg:`ERROR: ${t.length} files found. Workflow can only accept ${e}. Please move the extra files away.`,type:"WARNING_FILE_TOO_MANY"};return this.log.error(s.msg),void this.states.warnings.push(s)}this.states.upload.filesCount+=t.length;const a=t.map(async t=>{var n;if(e&&this.states.upload.filesCount>e){const s=`Maximum ${e} file(s) already uploaded. Marking ${t.relative} as skipped.`,i={msg:s,type:"WARNING_FILE_TOO_MANY"};this.log.error(s),this.states.warnings.push(i),this.states.upload.filesCount-=1,t.skip="SKIP_TOO_MANY"}else if(0===t.size){const e=`The file "${t.relative}" is empty. It will be skipped.`,s={msg:e,type:"WARNING_FILE_EMPTY"};t.skip="SKIP_EMPTY",this.states.upload.filesCount-=1,this.log.error(e),this.states.warnings.push(s)}else{if((null===(n=t.path)||void 0===n?void 0:n.match(/\.(?:fastq|fq)(?:\.gz)?$/))&&(i&&t.size>i||o)){const e=`${t.relative}${t.size>i?" is too big and":""} is going to be split`;this.log.warn(e);const s={msg:e,type:"WARNING_FILE_SPLIT"};this.states.warnings.push(s);const n=i?{maxChunkBytes:i}:{maxChunkReads:o},a=t.path.match(/\.gz$/)?Oe:Te,c=At.getFileID(),h=new Se({bandwidth:this.config.options.transferPoolSize});let u=0;const d=async e=>{if(this.log.debug("chunkHandler for "+e),!this.db)throw new Error("Database is required but not initialized");if(await this.db.splitFile(e,t.path),this.stopped)return h.stop(),this.log.info("stopped, so skipping "+e),Promise.reject(new Error("stopped"));u+=1;let s=null;for(const t of this.config.options.inputFolders)if(e.includes(t)){s=e.replace(t,"");break}const i=await be(e),o={name:l.basename(e),path:e,relative:ft(s),id:`${c}_${u}`,stats:i,size:i.bytes},n=new Promise(t=>{h.enqueue(async()=>{if(this.log.info(`chunk upload starting ${o.id} ${o.path}`),this.stopped)return this.log.info(`chunk upload skipped (stopped) ${o.id} ${o.path}`),h.stop(),void t();try{if(await this.uploadJob(o),!this.db)throw new Error("Database is required but not initialized");await this.db.splitDone(o.path)}catch(e){this.log.error(`chunk upload failed ${o.id} ${o.path}: ${String(e)}`)}t()})});await n};try{await a(t.path,n,d,this.log),h.stop()}catch(r){if(h.stop(),"Error: stopped"===String(r))return;throw r}if(!this.db)throw new Error("Database is required but not initialized");return this.db.uploadFile(t.path)}if(s&&t.size>s){const e=`The file "${t.relative}" is bigger than the maximum size limit (${ae(s)}B). It will be skipped.`,i={msg:e,type:"WARNING_FILE_TOO_BIG"};t.skip="SKIP_TOO_BIG",this.states.upload.filesCount-=1,this.log.error(e),this.states.warnings.push(i)}else try{t.stats=await be(t.path)}catch(a){this.log.error(`failed to stat ${t.path}: ${String(a)}`)}}return this.uploadJob(t)});try{return await Promise.all(a),this.log.info(`upload: inputBatchQueue (${a.length} jobs) complete`),this.loadUploadFiles()}catch(c){throw this.log.error("upload: enqueueUploadFiles exception "+String(c)),c}}async uploadJob(t){var e;if("skip"in t){if(!this.db)throw new Error("Database is required but not initialized");return void await this.db.skipFile(t.path)}let s,i=null;try{this.log.info(`upload: ${t.id} starting`),i=await this.uploadHandler(t),this.log.info(`upload: ${i.id} uploaded and notified`)}catch(o){s=o,this.log.error(`upload: ${t.id} done, but failed: ${String(s)}`)}if(s){if(this.log.error("uploadJob "+s),this.states.upload.failure||(this.states.upload.failure={}),this.states.upload.failure[s]=this.states.upload.failure[s]?gt(this.states.upload.failure[s])+1:1,String(s).match(/AWS.SimpleQueueService.NonExistentQueue/))return this.log.error("instance stopped because of a fatal error"),this.stopEverything()}else{const{bytes:t=0,reads:s=0,sequences:o=0}=null!==(e=null===i||void 0===i?void 0:i.stats)&&void 0!==e?e:{};if(this.uploadState("success","incr",{files:1,bytes:t,reads:s,sequences:o}),null===i||void 0===i?void 0:i.name){const t=l.extname(i.name);this.uploadState("types","incr",{[t]:1})}}}async receiveMessages(t){if(!t||!t.Messages||!t.Messages.length)return void this.log.info("complete (empty)");this.downloadWorkerPool||(this.downloadWorkerPool={});const e=this.downloadWorkerPool;for(const s of t.Messages){const t=wt(s.MessageId);e[t]=1;const i=de(1e3*(60+this.config.options.downloadTimeout),()=>{throw this.log.error("this.downloadWorkerPool timeoutHandle. Clearing queue slot for message: "+s.MessageId),new Error("download timed out")});this.processMessage(s).catch(t=>{this.log.error("processMessage "+String(t))}).finally(()=>{i(),s&&delete e[t]})}this.log.info(`downloader queued ${t.Messages.length} messages for processing`)}async processMessage(t){var i,o,n,r;let c,h;if(!t)return void this.log.debug("download.processMessage: empty message");t.Attributes&&"ApproximateReceiveCount"in t.Attributes&&this.log.debug(`download.processMessage: ${t.MessageId} / ${t.Attributes.ApproximateReceiveCount}`);try{c=JSON.parse(ft(t.Body))}catch(m){this.log.error(`error parsing JSON message.Body from message: ${JSON.stringify(t)} ${String(m)}`);try{await this.deleteMessage(t)}catch(y){this.log.error("Exception deleting message: "+String(y))}return}const u=xt(c.telemetry);if(u){if(u.tm_path)try{this.log.debug(`download.processMessage: ${t.MessageId} fetching telemetry`);const e=await this.sessionedS3(),s=await e.getObject({Bucket:ft(c.bucket),Key:ft(u.tm_path)}).promise();this.log.info(`download.processMessage: ${t.MessageId} fetched telemetry`);const i=s.Body;if(dt(i))throw new Error("Telemetry body is undefined");u.batch=i.toString("utf-8").split("\n").filter(t=>(null===t||void 0===t?void 0:t.length)>0).map(t=>{try{return JSON.parse(t)}catch(y){return this.log.error("Telemetry Batch JSON Parse error: "+String(y)),t}})}catch(v){this.log.error("Could not fetch telemetry JSON: "+String(v))}try{if(!this.telemetryLogStream)throw new Error("Telemetry log stream is not initialized");this.telemetryLogStream.write(JSON.stringify(u)+a)}catch(b){this.log.error("error writing telemetry: "+b)}this.config.options.telemetryCb&&this.config.options.telemetryCb(u)}if(!c.path)return void this.log.warn("nothing to download");const d=ft(c.path).match(/[\w\W]*\/([\w\W]*?)$/),p=d?d[1]:"",f=this.config.instance.id_workflow_instance;h=l.join(ft(this.config.options.outputFolder),dt(f)?"":wt(f));const g=It(null===(i=xt(null===u||void 0===u?void 0:u.hints))||void 0===i?void 0:i.folder);if(g){this.log.debug("using folder hint "+g);const t=g.split("/").map(t=>t.toUpperCase());h=l.join.apply(null,[h,...t])}e.mkdirpSync(h);const w=l.join(h,p);if("data+telemetry"===this.config.options.downloadMode){const e=[""],s=xt(null===(o=this.config.workflow)||void 0===o?void 0:o.settings);let i=Et(null===s||void 0===s?void 0:s.output_format,ft,[]);("string"===typeof i||i instanceof String)&&(i=i.trim().split(/[\s,]+/));try{e.push(...i)}catch(y){this.log.error("Failed to work out workflow file suffixes: "+String(y))}try{const s=e.map(e=>{const s=c.path+e,i=w+e;return this.log.debug(`download.processMessage: ${t.MessageId} downloading ${s} to ${i}`),new Promise((o,n)=>{this.initiateDownloadStream({bucket:ft(c.bucket),path:s},t,i).then(o).catch(t=>{this.log.error("Caught exception waiting for initiateDownloadStream: "+String(t)),e?n(t):o()})})});await Promise.all(s)}catch(y){this.log.error("Exception fetching file batch: "+String(y))}try{const t=null!==(n=null===u||void 0===u?void 0:u.json)&&void 0!==n&&n;t&&this.config.options.dataCb&&this.config.options.dataCb(w,t)}catch(v){this.log.warn("failed to fire data callback: "+v)}}else{const t=xt(null===u||void 0===u?void 0:u.batch_summary),e=null!==(r=$t(null===t||void 0===t?void 0:t.reads_num))&&void 0!==r?r:1;this.downloadState("success","incr",{files:1,reads:e})}try{await this.deleteMessage(t)}catch(y){this.log.error("Exception deleting message: "+String(y))}this.realtimeFeedback("workflow_instance:state",{type:"stop",id_workflow_instance:this.config.instance.id_workflow_instance,id_workflow:this.config.instance.id_workflow,component_id:"0",message_id:s(t).MessageId,id_user:this.config.instance.id_user}).catch(t=>{this.log.warn("realtimeFeedback failed: "+String(t))})}async initiateDownloadStream(t,s,i){return new Promise(async(o,n)=>{let r,a,c;try{r=await this.sessionedS3()}catch(d){n(d)}const h=s=>{if(this.log.error(`Error during stream of bucket=${t.bucket} path=${t.path} to file=${i} ${String(s)}`),this.stopTimeout("transferTimeouts",i),!xe.has(a))try{xe.add(a),a.close(),e.remove(i).then(()=>{this.log.warn("removed failed download "+i)}).catch(t=>{this.log.warn(`failed to remove ${i}. unlinkException: ${String(t)}`)}),c instanceof e.ReadStream&&c.destroy&&(this.log.error("destroying read stream for "+i),c.destroy())}catch(d){this.log.error("error handling stream error: "+String(d))}};try{const s={Bucket:t.bucket,Key:t.path};if(a=e.createWriteStream(i),!r)throw new Error("S3 is required but not initialized");const o=r.getObject(s);o.on("httpHeaders",(t,e)=>{this.downloadState("progress","incr",{total:parseInt(e["content-length"],10)})}),c=o.createReadStream()}catch(p){return this.log.error("getObject/createReadStream exception: "+String(p)),void n(p)}c.on("error",h),a.on("finish",async()=>{if(!xe.has(a)){this.log.debug("downloaded "+i);try{const t=l.extname(i),{bytes:e,reads:s,sequences:o}=await be(i);this.downloadState("success","incr",{files:1,bytes:e,reads:s,sequences:o}),this.downloadState("types","incr",{[t]:1}),this.downloadState("progress","decr",{total:e,bytes:e})}catch(t){this.log.warn(`failed to stat ${i}: ${String(t)}`)}this.reportProgress()}}),a.on("close",e=>{this.log.debug("closing writeStream "+i),e&&this.log.error("error closing write stream "+e);const n=this.timers.visibilityIntervals[i];n&&(n(),delete this.timers.visibilityIntervals[i]);const r=this.timers.transferTimeouts[i];r&&(r(),delete this.timers.transferTimeouts[i]),setTimeout(this.checkForDownloads.bind(this)),this.log.info(`download.initiateDownloadStream: ${s.MessageId} downloaded ${t.path} to ${i}`),o()}),a.on("error",h);const u=()=>{h(new Error("transfer timed out"))};this.timers.transferTimeouts[i]=de(1e3*this.config.options.downloadTimeout,u);this.timers.visibilityIntervals[i]=ue(900*this.config.options.inFlightDelay,async()=>{if(this.stopped){const t=this.timers.visibilityIntervals[i];t&&(t(),delete this.timers.visibilityIntervals[i])}const t=this.config.instance.outputQueueURL,e=s.ReceiptHandle;this.log.debug({message_id:s.MessageId},"updateVisibility");try{const s=await this.sessionedSQS();await s.changeMessageVisibility({QueueUrl:ft(t),ReceiptHandle:ft(e),VisibilityTimeout:this.config.options.inFlightDelay}).promise()}catch(o){this.log.error({message_id:s.MessageId,queue:t,error:o},"Error setting visibility");const e=this.timers.visibilityIntervals[i];e&&(e(),delete this.timers.visibilityIntervals[i])}}),c.on("data",t=>{const e=this.timers.transferTimeouts[i];e&&e(),this.timers.transferTimeouts[i]=de(1e3*this.config.options.downloadTimeout,u),this.downloadState("progress","incr",{bytes:t.length})}).pipe(a)})}async uploadHandler(s){const i=await this.sessionedS3();let o,n=!1;const r=s.relative.replace(/^[\\/]+/,"").replace(/\\/g,"/").replace(/\//g,"_"),a=[this.config.instance.bucketFolder,"component-0",r,r].join("/").replace(/\/+/g,"/");let l;return new Promise((r,c)=>{const h=()=>{o&&!n&&o.close(),c(new Error(s.name+" timed out"))};l=de(1e3*(this.config.options.uploadTimeout+5),h);try{o=e.createReadStream(s.path),o.on("close",()=>{n=!0})}catch(u){return l(),void c(u)}o.on("error",t=>{o.close();let e="error in upload readstream";(null===t||void 0===t?void 0:t.message)&&(e+=": "+t.message),l(),c(new Error(e))}),o.on("open",async()=>{var e;const n={Bucket:ft(this.config.instance.bucket),Key:a,Body:o},u=new t.S3,d={partSize:10485760,queueSize:1,service:u};this.config.instance.key_id&&(n.SSEKMSKeyId=this.config.instance.key_id,n.ServerSideEncryption="aws:kms"),s.size&&(n["Content-Length"]=s.size),this.uploadState("progress","incr",{total:s.size});let p=0;const f=i.upload(n,d);this.uploadsInProgress.push(f);const g=this.initSessionManager(null,[u]);g.sts_expiration=null===(e=this.sessionManager)||void 0===e?void 0:e.sts_expiration,f.on("httpUploadProgress",async t=>{this.uploadState("progress","incr",{bytes:t.loaded-p}),p=t.loaded,l(),l=de(1e3*(this.config.options.uploadTimeout+5),h);try{await g.session()}catch(e){this.log.warn("Error refreshing token: "+String(e))}});try{await f.promise(),this.log.info(s.id+" S3 upload complete"),o.close(),l(),await this.uploadComplete(a,s),r(s)}catch(w){this.log.warn(`${s.id} uploadStreamError ${w}`),c(w)}finally{this.uploadState("progress","decr",{total:s.size,bytes:s.size}),this.uploadsInProgress=this.uploadsInProgress.filter(t=>t!==f)}})})}async uploadComplete(t,e){this.log.info(`${e.id} uploaded to S3: ${t}`);const i={bucket:this.config.instance.bucket,outputQueue:this.config.instance.outputQueueName,remote_addr:this.config.instance.remote_addr,apikey:this.config.options.apikey,id_workflow_instance:this.config.instance.id_workflow_instance,id_master:this.config.instance.id_workflow,utc:(new Date).toISOString(),path:t,prefix:t.substring(0,t.lastIndexOf("/"))};if(this.config.instance.chain)try{i.components=JSON.parse(JSON.stringify(this.config.instance.chain.components)),i.targetComponentId=this.config.instance.chain.targetComponentId}catch(n){return this.log.error(`${e.id} exception parsing components JSON ${String(n)}`),Promise.reject(n)}if(this.config.instance.key_id&&(i.key_id=this.config.instance.key_id),this.config.options.agent_address)try{i.agent_address=JSON.parse(this.config.options.agent_address)}catch(r){this.log.error(`${e.id} Could not parse agent_address ${String(r)}`)}if(i.components){const t=function(t,e,s){if(pt(t)&&"undefined"!==typeof s)return s;if("object"===typeof t&&!1===Array.isArray(t)){const s=St(t),i={};for(const o in t)i[o]=e(s[o]);return i}throw new Error(`Unable to cast ${typeof t} to Record`)}(i.components,St);for(const e of Object.values(t))switch(null===e||void 0===e?void 0:e.inputQueueName){case"uploadMessageQueue":e.inputQueueName=this.uploadMessageQueue;break;case"downloadMessageQueue":e.inputQueueName=this.downloadMessageQueue}}let o={};try{const t=await this.discoverQueue(It(this.config.instance.inputQueueName)),s=await this.sessionedSQS();this.log.info(e.id+" sending SQS message to input queue"),o=await s.sendMessage({QueueUrl:t,MessageBody:JSON.stringify(i)}).promise()}catch(a){return this.log.error(`${e.id} exception sending SQS message: ${String(a)}`),Promise.reject(a)}if(this.realtimeFeedback("workflow_instance:state",{type:"start",id_workflow_instance:this.config.instance.id_workflow_instance,id_workflow:this.config.instance.id_workflow,component_id:"0",message_id:s(o).MessageId,id_user:this.config.instance.id_user}).catch(t=>{this.log.warn("realtimeFeedback failed: "+String(t))}),this.log.info(e.id+" SQS message sent. Mark as uploaded"),!this.db)throw new Error("Database has not been instantiated");return this.db.uploadFile(e.path)}async fetchTelemetry(){var t,s;if(!(null===(s=null===(t=this.config)||void 0===t?void 0:t.instance)||void 0===s?void 0:s.summaryTelemetry))return;const i=l.join(je(),"instances"),o=l.join(i,this.config.instance.id_workflow_instance+""),n=[],r=St(this.config.instance.summaryTelemetry);Object.keys(r).forEach(t=>{var s;const i=null!==(s=St(r[t]))&&void 0!==s?s:{};let a=It(i[Object.keys(i)[0]]);if(!a)return;a.startsWith("http")||(a=q(this.config.options.url,a));const c=l.join(o,t+".json");n.push((async()=>{try{const t=await this.REST.fetchContent(a);return e.writeJSONSync(c,t),this.reportState$.next(!0),this.log.debug("fetched telemetry summary "+c),t}catch(t){return this.log.debug("Error fetching telemetry",t),null}})())});try{const t=await Promise.all(n);this.instanceTelemetry$.next(t)}catch(a){this.log.warn("summary telemetry incomplete",a)}}}Pe.version=At.version,Pe.REST=_e,Pe.utils=At,Pe.SessionManager=Ie,Pe.EPI2ME_HOME=je(),Pe.Profile=ke,Pe.Factory=ge,Pe.GraphQL=re;const Re=At.version,Ae=Pe.EPI2ME_HOME;export{Pe as EPI2ME,Ae as EPI2ME_HOME,ge as Factory,re as GraphQL,ke as Profile,_e as REST,Ie as SessionManager,At as utils,Re as version};
