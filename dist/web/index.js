/**
 * Copyright Metrichor Ltd. (An Oxford Nanopore Technologies Company) 2020
 */

"use strict";function e(e){return e&&"object"===typeof e&&"default"in e?e.default:e}var t=require("lodash"),s=require("rxjs"),r=e(require("graphql-tag")),o=require("apollo-cache-inmemory"),i=e(require("apollo-client")),n=require("apollo-link"),a=require("apollo-link-http"),l=e(require("axios")),c=require("@lifeomic/axios-fetch"),u=e(require("crypto")),h=require("tunnel"),p=e(require("os")),d=e(require("socket.io-client")),g="https://epi2me.nanoporetech.com",f={local:!1,url:g,user_agent:"EPI2ME API",region:"eu-west-1",sessionGrace:5,uploadTimeout:1200,downloadTimeout:1200,fileCheckInterval:5,downloadCheckInterval:3,stateCheckInterval:60,inFlightDelay:600,waitTimeSeconds:20,waitTokenError:30,transferPoolSize:3,downloadMode:"data+telemetry",filetype:[".fastq",".fq",".fastq.gz",".fq.gz"],signing:!0};function w(e,t,s){return t in e?Object.defineProperty(e,t,{value:s,enumerable:!0,configurable:!0,writable:!0}):e[t]=s,e}const m="\npage\npages\nhasNext\nhasPrevious\ntotalCount\n",y="\nidWorkflowInstance\nstartDate\nworkflowImage{\n  workflow\n  {\n    rev\n    name\n  }\n}\n";const k=function(){const e=(e,t)=>{e.headers||(e.headers={});let s=t;if(s||(s={}),!s.apikey||!s.apisecret)return;e.headers["X-EPI2ME-APIKEY"]=s.apikey,e.headers["X-EPI2ME-SIGNATUREDATE"]=(new Date).toISOString();const r=[Object.keys(e.headers).sort().filter(e=>e.match(/^x-epi2me/i)).map(t=>`${t}:${e.headers[t]}`).join("\n"),e.body].join("\n"),o=u.createHmac("sha1",s.apisecret).update(r).digest("hex");e.headers["X-EPI2ME-SIGNATUREV0"]=o};return{version:"3.0.1027",setHeaders:(s,r)=>{const{log:o}=t.merge({log:{debug:()=>{}}},r);let i=r;if(i||(i={}),s.headers=t.merge({Accept:"application/json","Content-Type":"application/json","X-EPI2ME-CLIENT":i.user_agent||"api","X-EPI2ME-VERSION":i.agent_version||k.version},s.headers,i.headers),"signing"in i&&!i.signing||e(s,i),i.proxy){const e=i.proxy.match(/https?:\/\/((\S+):(\S+)@)?(\S+):(\d+)/),t=e[2],r=e[3],n={host:e[4],port:e[5]};t&&r&&(n.proxyAuth=`${t}:${r}`),i.proxy.match(/^https/)?(o.debug("using HTTPS over HTTPS proxy",JSON.stringify(n)),s.httpsAgent=h.httpsOverHttps({proxy:n})):(o.debug("using HTTPS over HTTP proxy",JSON.stringify(n)),s.httpsAgent=h.httpsOverHttp({proxy:n})),s.proxy=!1}}}}(),$=c.buildAxiosFetch(l),b=(e,t)=>{const{apikey:s,apisecret:r}=t.headers.keys;return delete t.headers.keys,k.setHeaders(t,{apikey:s,apisecret:r,signing:!0}),$(e,t)},I=new i({link:new n.ApolloLink(e=>{const{apikey:t,apisecret:s,url:r}=e.getContext(),o=a.createHttpLink({uri:`${r}/graphql`,fetch:b,headers:{keys:{apikey:t,apisecret:s}}});return n.execute(o,e)}),cache:new o.InMemoryCache});l.defaults.validateStatus=e=>e<=504;const v=function(){const e=(e,t)=>{e.headers||(e.headers={});let s=t;if(s||(s={}),!s.apikey)return;if(e.headers["X-EPI2ME-ApiKey"]=s.apikey,!s.apisecret)return;e.headers["X-EPI2ME-SignatureDate"]=(new Date).toISOString(),e.url.match(/^https:/)&&(e.url=e.url.replace(/:443/,"")),e.url.match(/^http:/)&&(e.url=e.url.replace(/:80/,""));const r=[e.url,Object.keys(e.headers).sort().filter(e=>e.match(/^x-epi2me/i)).map(t=>`${t}:${e.headers[t]}`).join("\n")].join("\n"),o=u.createHmac("sha1",s.apisecret).update(r).digest("hex");e.headers["X-EPI2ME-SignatureV0"]=o},s=async e=>{const t=e?e.data:null;if(!t)return Promise.reject(new Error("unexpected non-json response"));if(e&&e.status>=400){let s=`Network error ${e.status}`;return t.error&&(s=t.error),504===e.status&&(s="Please check your network connection and try again."),Promise.reject(new Error(s))}return t.error?Promise.reject(new Error(t.error)):Promise.resolve(t)};return{version:"3.0.1027",headers:(s,r)=>{const{log:o}=t.merge({log:{debug:()=>{}}},r);let i=r;if(i||(i={}),s.headers=t.merge({Accept:"application/json","Content-Type":"application/json","X-EPI2ME-Client":i.user_agent||"api","X-EPI2ME-Version":i.agent_version||v.version},s.headers,i.headers),"signing"in i&&!i.signing||e(s,i),i.proxy){const e=i.proxy.match(/https?:\/\/((\S+):(\S+)@)?(\S+):(\d+)/),t=e[2],r=e[3],n={host:e[4],port:e[5]};t&&r&&(n.proxyAuth=`${t}:${r}`),i.proxy.match(/^https/)?(o.debug("using HTTPS over HTTPS proxy",JSON.stringify(n)),s.httpsAgent=h.httpsOverHttps({proxy:n})):(o.debug("using HTTPS over HTTP proxy",JSON.stringify(n)),s.httpsAgent=h.httpsOverHttp({proxy:n})),s.proxy=!1}},get:async(e,r)=>{const{log:o}=t.merge({log:{debug:()=>{}}},r);let i,n=r.url,a=e;r.skip_url_mangle?i=a:(a=`/${a}`,n=n.replace(/\/+$/,""),a=a.replace(/\/+/g,"/"),i=n+a);const c={url:i,gzip:!0};let u;v.headers(c,r);try{o.debug(`GET ${c.url}`),u=await l.get(c.url,c)}catch(h){return Promise.reject(h)}return s(u,r)},post:async(e,r,o)=>{const{log:i}=t.merge({log:{debug:()=>{}}},o);let n=o.url;n=n.replace(/\/+$/,"");const a={url:`${n}/${e.replace(/\/+/g,"/")}`,gzip:!0,data:r,headers:{}};if(o.legacy_form){const e=[],s=t.merge({json:JSON.stringify(r)},r);Object.keys(s).sort().forEach(t=>{e.push(`${t}=${escape(s[t])}`)}),a.data=e.join("&"),a.headers["Content-Type"]="application/x-www-form-urlencoded"}v.headers(a,o);const{data:c}=a;let u;delete a.data;try{i.debug(`POST ${a.url}`),u=await l.post(a.url,c,a)}catch(h){return Promise.reject(h)}return o.handler?o.handler(u):s(u,o)},put:async(e,r,o,i)=>{const{log:n}=t.merge({log:{debug:()=>{}}},i);let a=i.url;a=a.replace(/\/+$/,"");const c={url:`${a}/${e.replace(/\/+/g,"/")}/${r}`,gzip:!0,data:o,headers:{}};if(i.legacy_form){const e=[],s=t.merge({json:JSON.stringify(o)},o);Object.keys(s).sort().forEach(t=>{e.push(`${t}=${escape(s[t])}`)}),c.data=e.join("&"),c.headers["Content-Type"]="application/x-www-form-urlencoded"}v.headers(c,i);const{data:u}=c;let h;delete c.data;try{n.debug(`PUT ${c.url}`),h=await l.put(c.url,u,c)}catch(p){return Promise.reject(p)}return s(h,i)}}}();class S{constructor(e){w(this,"createContext",e=>{const{apikey:s,apisecret:r,url:o}=this.options;return t.merge({apikey:s,apisecret:r,url:o},e)}),w(this,"query",e=>({context:t={},variables:s={},options:o={}}={})=>{const i=this.createContext(t);let n;return n="string"===typeof e?r`
        ${e}
      `:"function"===typeof e?r`
        ${e(m)}
      `:e,this.client.query({query:n,variables:s,...o,context:i})}),w(this,"mutate",e=>({context:t={},variables:s={},options:o={}}={})=>{const i=this.createContext(t);let n;return n="string"===typeof e?r`
        ${e}
      `:e,this.client.mutate({mutation:n,variables:s,...o,context:i})}),w(this,"resetCache",()=>{this.client.resetStore()}),w(this,"workflows",this.query(r`
    query allWorkflows($page: Int, $pageSize: Int, $isActive: Int, $orderBy: String) {
      allWorkflows(page: $page, pageSize: $pageSize, isActive: $isActive, orderBy: $orderBy) {
        ${m}
        results {
          ${"\nidWorkflow\nname\ndescription\nsummary\nrev\n"}
        }
      }
    }
  `)),w(this,"workflowPages",async e=>{let t=e,s=await this.workflows({variables:{page:t}});const r=async e=>(t=e,s=await this.workflows({variables:{page:t}}),s);return{data:s,next:()=>r(t+1),previous:()=>r(t-1),first:()=>r(1),last:()=>r(0)}}),w(this,"workflow",this.query(r`
    query workflow($idWorkflow: ID!) {
      workflow(idWorkflow: $idWorkflow) {
        ${"\nidWorkflow\nname\ndescription\nsummary\nrev\n"}
      }
    }
   `)),w(this,"workflowInstances",this.query(r`
  query allWorkflowInstances($page: Int, $pageSize: Int, $shared: Boolean, $idUser: ID, $orderBy: String) {
    allWorkflowInstances(page: $page, pageSize: $pageSize, shared: $shared, idUser: $idUser, orderBy: $orderBy) {
      ${m}
      results {
        ${y}
      }
    }
  }
   `)),w(this,"workflowInstance",this.query(r`
      query workflowInstance($idWorkflowInstance: ID!) {
        workflowInstance(idWorkflowInstance: $idWorkflowInstance) {
          ${y}
        }
      }
   `)),w(this,"startWorkflow",this.mutate(r`
    mutation startWorkflow(
      $idWorkflow: ID!
      $computeAccountId: Int!
      $storageAccountId: Int
      $isConsentedHuman: Int = 0
    ) {
      startWorkflowInstance(
        idWorkflow: $idWorkflow
        computeAccountId: $computeAccountId
        storageAccountId: $storageAccountId
        isConsentedHuman: $isConsentedHuman
      ) {
        bucket
        idUser
        idWorkflowInstance
        inputqueue
        outputqueue
        region
        keyId
        chain
      }
    }
  `)),w(this,"user",this.query(r`
    query user {
      me {
        username
        realname
        useraccountSet {
          idUserAccount
        }
      }
    }
  `)),w(this,"register",this.mutate(r`
    mutation registerToken($code: String!, $description: String) {
      registerToken(code: $code, description: $description) {
        apikey
        apisecret
        description
      }
    }
  `)),this.options=t.assign({agent_version:v.version,local:!1,url:g,user_agent:"EPI2ME API",signing:!0},e),this.options.url=this.options.url.replace(/:\/\//,"://graphql."),this.log=this.options.log,this.client=I}}const E=(e,t)=>{const s=["","K","M","G","T","P","E","Z"];let r=t||0,o=e||0;return o>=1e3?(o/=1e3,r+=1,r>=s.length?"???":E(o,r)):0===r?`${o}${s[r]}`:`${o.toFixed(1)}${s[r]}`};class P{constructor(e){this.options=t.assign({agent_version:v.version,local:!1,url:g,user_agent:"EPI2ME API",signing:!0},e),this.log=this.options.log}async list(e){const t=e.match(/^[a-z_]+/i)[0];return v.get(e,this.options).then(e=>e[`${t}s`])}async read(e,t){return v.get(`${e}/${t}`,this.options)}async user(){return this.options.local?{accounts:[{id_user_account:"none",number:"NONE",name:"None"}]}:v.get("user",this.options)}async status(){return v.get("status",this.options)}async jwt(){return v.post("authenticate",{},t.merge({handler:e=>e.headers["x-epi2me-jwt"]?Promise.resolve(e.headers["x-epi2me-jwt"]):Promise.reject(new Error("failed to fetch JWT"))},this.options))}async instanceToken(e,s){return v.post("token",t.merge(s,{id_workflow_instance:e}),t.assign({},this.options,{legacy_form:!0}))}async installToken(e){return v.post("token/install",{id_workflow:e},t.assign({},this.options,{legacy_form:!0}))}async attributes(){return this.list("attribute")}async workflows(){return this.list("workflow")}async amiImages(){if(this.options.local)throw new Error("amiImages unsupported in local mode");return this.list("ami_image")}async amiImage(e,t){let s,r,o;if(e&&t instanceof Object?(s=e,r=t,o="update"):e instanceof Object&&!t?(r=e,o="create"):(o="read",s=e),this.options.local)throw new Error("ami_image unsupported in local mode");if("update"===o)return v.put("ami_image",s,r,this.options);if("create"===o)return v.post("ami_image",r,this.options);if(!s)throw new Error("no id_ami_image specified");return this.read("ami_image",s)}async workflow(e,s,r){let o,i,n,a;if(e&&s&&r instanceof Function?(o=e,i=s,n=r,a="update"):e&&s instanceof Object&&!(s instanceof Function)?(o=e,i=s,a="update"):e instanceof Object&&s instanceof Function?(i=e,n=s,a="create"):e instanceof Object&&!s?(i=e,a="create"):(a="read",o=e,n=s instanceof Function?s:null),"update"===a)try{const e=await v.put("workflow",o,i,this.options);return n?n(null,e):Promise.resolve(e)}catch(h){return n?n(h):Promise.reject(h)}if("create"===a)try{const e=await v.post("workflow",i,this.options);return n?n(null,e):Promise.resolve(e)}catch(h){return n?n(h):Promise.reject(h)}if(!o){const e=new Error("no workflow id specified");return n?n(e):Promise.reject(e)}const l={};try{const e=await this.read("workflow",o);if(e.error)throw new Error(e.error);t.merge(l,e)}catch(h){return this.log.error(`${o}: error fetching workflow ${String(h)}`),n?n(h):Promise.reject(h)}t.merge(l,{params:{}});try{const e=await v.get(`workflow/config/${o}`,this.options);if(e.error)throw new Error(e.error);t.merge(l,e)}catch(h){return this.log.error(`${o}: error fetching workflow config ${String(h)}`),n?n(h):Promise.reject(h)}const c=t.filter(l.params,{widget:"ajax_dropdown"}),u=[...c.map((e,t)=>{const s=c[t];return new Promise((e,t)=>{const r=s.values.source.replace("{{EPI2ME_HOST}}","").replace(/&?apikey=\{\{EPI2ME_API_KEY\}\}/,"");v.get(r,this.options).then(t=>{const r=t[s.values.data_root];return r&&(s.values=r.map(e=>({label:e[s.values.items.label_key],value:e[s.values.items.value_key]}))),e()}).catch(e=>(this.log.error(`failed to fetch ${r}`),t(e)))})})];try{return await Promise.all(u),n?n(null,l):Promise.resolve(l)}catch(h){return this.log.error(`${o}: error fetching config and parameters ${String(h)}`),n?n(h):Promise.reject(h)}}async startWorkflow(e){return v.post("workflow_instance",e,t.assign({},this.options,{legacy_form:!0}))}async stopWorkflow(e){return v.put("workflow_instance/stop",e,null,t.assign({},this.options,{legacy_form:!0}))}async workflowInstances(e){return e&&e.run_id?v.get(`workflow_instance/wi?show=all&columns[0][name]=run_id;columns[0][searchable]=true;columns[0][search][regex]=true;columns[0][search][value]=${e.run_id};`,this.options).then(e=>e.data.map(e=>({id_workflow_instance:e.id_ins,id_workflow:e.id_flo,run_id:e.run_id,description:e.desc,rev:e.rev}))):this.list("workflow_instance")}async workflowInstance(e){return this.read("workflow_instance",e)}async workflowConfig(e){return v.get(`workflow/config/${e}`,this.options)}async register(e,s){return v.put("reg",e,{description:s||`${p.userInfo().username}@${p.hostname()}`},t.assign({},this.options,{signing:!1}))}async datasets(e){let t=e;return t||(t={}),t.show||(t.show="mine"),this.list(`dataset?show=${t.show}`)}async dataset(e){return this.options.local?this.datasets().then(t=>t.find(t=>t.id_dataset===e)):this.read("dataset",e)}async fetchContent(e){const s=t.assign({},this.options,{skip_url_mangle:!0,headers:{"Content-Type":""}});return v.get(e,s)}}class j{constructor(e,s){this.debounces={},this.debounceWindow=t.merge({debounceWindow:2e3},s).debounceWindow,this.log=t.merge({log:{debug:()=>{}}},s).log,e.jwt().then(e=>{this.socket=d(s.url,{transportOptions:{polling:{extraHeaders:{Cookie:`x-epi2me-jwt=${e}`}}}}),this.socket.on("connect",()=>{this.log.debug("socket ready")})})}debounce(e,s){const r=t.merge(e)._uuid;if(r){if(this.debounces[r])return;this.debounces[r]=1,setTimeout(()=>{delete this.debounces[r]},this.debounceWindow)}s&&s(e)}watch(e,t){if(!this.socket)return this.log.debug(`socket not ready. requeueing watch on ${e}`),void setTimeout(()=>{this.watch(e,t)},1e3);this.socket.on(e,e=>this.debounce(e,t))}emit(e,t){if(!this.socket)return this.log.debug(`socket not ready. requeueing emit on ${e}`),void setTimeout(()=>{this.emit(e,t)},1e3);this.log.debug(`socket emit ${e} ${JSON.stringify(t)}`),this.socket.emit(e,t)}}class T{constructor(e){let r;if(r="string"===typeof e||"object"===typeof e&&e.constructor===String?JSON.parse(e):e||{},r.endpoint&&(r.url=r.endpoint,delete r.endpoint),r.log){if(!t.every([r.log.info,r.log.warn,r.log.error,r.log.debug,r.log.json],t.isFunction))throw new Error("expected log object to have error, debug, info, warn and json methods");this.log=r.log}else this.log={info:e=>{console.info(`[${(new Date).toISOString()}] INFO: ${e}`)},debug:e=>{console.debug(`[${(new Date).toISOString()}] DEBUG: ${e}`)},warn:e=>{console.warn(`[${(new Date).toISOString()}] WARN: ${e}`)},error:e=>{console.error(`[${(new Date).toISOString()}] ERROR: ${e}`)},json:e=>{console.log(JSON.stringify(e))}};this.stopped=!0,this.uploadState$=new s.BehaviorSubject(!1),this.analyseState$=new s.BehaviorSubject(!1),this.reportState$=new s.BehaviorSubject(!1),this.runningStates$=s.combineLatest(this.uploadState$,this.analyseState$,this.reportState$),this.states={upload:{filesCount:0,success:{files:0,bytes:0,reads:0},types:{},niceTypes:"",progress:{bytes:0,total:0}},download:{progress:{},success:{files:0,reads:0,bytes:0},fail:0,types:{},niceTypes:""},warnings:[]},this.liveStates$=new s.BehaviorSubject(this.states),this.config={options:t.defaults(r,f),instance:{id_workflow_instance:r.id_workflow_instance,inputQueueName:null,outputQueueName:null,outputQueueURL:null,discoverQueueCache:{},bucket:null,bucketFolder:null,remote_addr:null,chain:null,key_id:null}},this.config.instance.awssettings={region:this.config.options.region},this.REST=new P(t.merge({log:this.log},this.config.options)),this.graphQL=new S(t.merge({log:this.log},this.config.options)),this.timers={downloadCheckInterval:null,stateCheckInterval:null,fileCheckInterval:null,transferTimeouts:{},visibilityIntervals:{},summaryTelemetryInterval:null}}async socket(){return this.mySocket?this.mySocket:(this.mySocket=new j(this.REST,t.merge({log:this.log},this.config.options)),this.mySocket)}async realtimeFeedback(e,t){(await this.socket()).emit(e,t)}stopTimer(e){this.timers[e]&&(this.log.debug(`clearing ${e} interval`),clearInterval(this.timers[e]),this.timers[e]=null)}async stopAnalysis(){this.stopUpload();const{id_workflow_instance:e}=this.config.instance;if(e){try{await this.REST.stopWorkflow(e),this.analyseState$.next(!1)}catch(t){return this.log.error(`Error stopping instance: ${String(t)}`),Promise.reject(t)}this.log.info(`workflow instance ${e} stopped`)}return Promise.resolve()}async stopUpload(){return this.stopped=!0,this.log.debug("stopping watchers"),["downloadCheckInterval","stateCheckInterval","fileCheckInterval"].forEach(e=>this.stopTimer(e)),this.uploadState$.next(!1),Object.keys(this.timers.transferTimeouts).forEach(e=>{this.log.debug(`clearing transferTimeout for ${e}`),clearTimeout(this.timers.transferTimeouts[e]),delete this.timers.transferTimeouts[e]}),Object.keys(this.timers.visibilityIntervals).forEach(e=>{this.log.debug(`clearing visibilityInterval for ${e}`),clearInterval(this.timers.visibilityIntervals[e]),delete this.timers.visibilityIntervals[e]}),this.downloadWorkerPool&&(this.log.debug("clearing downloadWorkerPool"),await Promise.all(Object.values(this.downloadWorkerPool)),this.downloadWorkerPool=null),Promise.resolve()}async stopEverything(){this.stopAnalysis(),this.stopTimer("summaryTelemetryInterval")}reportProgress(){const{upload:e,download:t}=this.states;this.log.json({progress:{download:t,upload:e}})}storeState(e,t,s,r){const o=r||{};this.states[e]||(this.states[e]={}),this.states[e][t]||(this.states[e][t]={}),"incr"===s?Object.keys(o).forEach(s=>{this.states[e][t][s]=this.states[e][t][s]?this.states[e][t][s]+parseInt(o[s],10):parseInt(o[s],10)}):Object.keys(o).forEach(s=>{this.states[e][t][s]=this.states[e][t][s]?this.states[e][t][s]-parseInt(o[s],10):-parseInt(o[s],10)});try{this.states[e].success.niceReads=E(this.states[e].success.reads)}catch(n){this.states[e].success.niceReads=0}try{this.states[e].progress.niceSize=E(this.states[e].success.bytes+this.states[e].progress.bytes||0)}catch(n){this.states[e].progress.niceSize=0}try{this.states[e].success.niceSize=E(this.states[e].success.bytes)}catch(n){this.states[e].success.niceSize=0}this.states[e].niceTypes=Object.keys(this.states[e].types||{}).sort().map(t=>`${this.states[e].types[t]} ${t}`).join(", ");const i=Date.now();(!this.stateReportTime||i-this.stateReportTime>2e3)&&(this.stateReportTime=i,this.reportProgress()),this.liveStates$.next({...this.states})}uploadState(e,t,s){return this.storeState("upload",e,t,s)}downloadState(e,t,s){return this.storeState("download",e,t,s)}url(){return this.config.options.url}apikey(){return this.config.options.apikey}attr(e,t){if(!(e in this.config.options))throw new Error(`config object does not contain property ${e}`);return t?(this.config.options[e]=t,this):this.config.options[e]}stats(e){return this.states[e]}}T.version=v.version,T.Profile=class{constructor(e,s){this.allProfileData={},this.defaultEndpoint=process.env.METRICHOR||f.endpoint||f.url,this.raiseExceptions=s,e&&(this.allProfileData=t.merge(e,{profiles:{}})),this.allProfileData.endpoint&&(this.defaultEndpoint=this.allProfileData.endpoint)}profile(e){return e?t.merge({endpoint:this.defaultEndpoint},this.allProfileData.profiles[e]):{}}profiles(){return Object.keys(this.allProfileData.profiles||{})}},T.REST=P,T.utils=v,module.exports=T;
